Index: Rawr.Tree/Actions.cs
===================================================================
--- Rawr.Tree/Actions.cs	(revision 0)
+++ Rawr.Tree/Actions.cs	(revision 0)
@@ -0,0 +1,535 @@
+ï»¿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+
+namespace Rawr.Tree
+{
+	public class Action : ICloneable
+	{
+		public double MPS;
+		public double Time;
+		public double DirectPS;
+		public double OverTimePS;
+
+		public double EPS { get { return DirectPS + OverTimePS; } }
+		public double Direct { get { return DirectPS * Time; } set { DirectPS = value / Time; } }
+		public double OverTime { get { return OverTimePS * Time; } set { OverTimePS = value / Time; }  }
+		public double Effect { get { return EPS * Time; } }
+		public double EPM { get { return EPS / MPS; } }
+		public double Mana { get { return MPS * Time; } set { MPS = value / Time; } }
+
+		public void ChangeTime(double tm)
+		{
+			DirectPS = Direct / tm;
+			OverTimePS = OverTime / tm;
+			MPS = Mana / tm;
+			Time = tm;
+		}
+
+		public KeyValuePair<string, string>[] GetSuccinctValues(bool heal)
+		{
+			List<KeyValuePair<string, string>> retVal = new List<KeyValuePair<string, string>>();
+			String s;
+			if (Effect > 0.0f)
+			{
+				s = String.Format("{0:F0} = ", EPS);
+				if (Direct > 0.0f && OverTime > 0.0f)
+					s += String.Format("({0:F0}+{1:F0})", Direct, OverTime);
+				else if (Direct > 0.0f)
+					s += String.Format("{0:F0}", Direct);
+				else if (OverTime > 0.0f)
+					s += String.Format("{0:F0}", OverTime);
+				else
+					s += "0";
+				s += String.Format("/{0:F2}", Time);
+			}
+			else
+				s = "";
+			retVal.Add(new KeyValuePair<string, string>(heal ? "HPS" : "DPS", s));
+
+			if (Mana > 0.0f)
+				s = String.Format("{2:F0} = {0:F0}/{1:F2}", Mana, Time, MPS);
+			else
+				s = "";
+			retVal.Add(new KeyValuePair<string, string>("MPS", s));
+
+			if (Effect > 0.0f && Mana > 0.0f)
+				s = String.Format("{2:F2} = {0:F0}/{1:F0}", Effect, Mana, EPM);
+			else
+				s = "";
+			retVal.Add(new KeyValuePair<string, string>(heal ? "HPM" : "DPM", s));
+			return retVal.ToArray();
+		}
+
+		public KeyValuePair<string, double>[] GetValues(bool heal)
+		{
+			List<KeyValuePair<string, double>> retVal = new List<KeyValuePair<string, double>>();
+			retVal.Add(new KeyValuePair<string, double>(heal ? "HPS" : "DPS", EPS));
+			retVal.Add(new KeyValuePair<string, double>("MPS", MPS));
+			retVal.Add(new KeyValuePair<string, double>(heal ? "HPM" : "DPM", EPM));
+			retVal.Add(new KeyValuePair<string, double>("Mana", Mana));
+			retVal.Add(new KeyValuePair<string, double>(heal ? "Heal" : "Dmg", Effect));
+			retVal.Add(new KeyValuePair<string, double>(heal ? "DH" : "DD", Direct));
+			retVal.Add(new KeyValuePair<string, double>(heal ? "HoT" : "DoT", OverTime));
+			retVal.Add(new KeyValuePair<string, double>("Time", Time));
+			return retVal.ToArray();
+		}
+
+		public object Clone()
+		{
+			return (Action)this.MemberwiseClone();
+		}
+
+		public static String GetName(object action)
+		{
+			string name = Enum.GetName(action.GetType(), action);
+			StringBuilder bld = new StringBuilder();
+			bool lastWasInitial = true;
+			foreach (char c in name)
+			{
+				if (Char.IsUpper(c))
+				{
+					if (!lastWasInitial)
+						bld.Append(' ');
+					lastWasInitial = true;
+				}
+				else
+					lastWasInitial = false;
+				bld.Append(c);
+			}
+			return bld.ToString();
+		}
+	};
+
+	public class ActionDistribution : ICloneable
+	{
+		public Action[] Actions;
+		public double[] Fraction;
+		public double[] EPS;
+		public double[] MPS;
+		public double TotalFraction = 0.0f;
+		public double TotalEPS = 0.0f;
+		public double TotalMPS = 0.0f;
+		public double MaxFraction = 1.0f;
+		public double MaxMPS = double.PositiveInfinity;
+
+		public object Clone()
+		{
+			ActionDistribution clone = (ActionDistribution)this.MemberwiseClone();
+			clone.EPS = (double[])clone.EPS.Clone();
+			clone.MPS = (double[])clone.MPS.Clone();
+			clone.Fraction = (double[])clone.Fraction.Clone();
+			return clone;
+		}
+
+
+		public ActionDistribution(Action[] actions)
+		{
+			Actions = actions;
+			Fraction = new double[Actions.Length];
+			EPS = new double[Actions.Length];
+			MPS = new double[Actions.Length];
+		}
+
+		public void AddAction(int action, double t)
+		{
+			t = Math.Min(t, MaxFraction - TotalFraction);
+			if(Actions[action].MPS > 0)
+				t = Math.Min(t, (MaxMPS - TotalMPS) / Actions[action].MPS);
+			if (t <= 0.0)
+				return;
+			
+			Fraction[(int)action] += t;
+			TotalFraction += t;
+			double eps = Actions[action].EPS * t;
+			double mps = Actions[action].MPS * t;
+			EPS[(int)action] += eps;
+			TotalEPS += eps;
+			MPS[(int)action] += mps;
+			TotalMPS += mps;
+		}
+
+		public void AddActionPeriodically(int action, double period)
+		{
+			AddAction(action, Actions[(int)action].Time / period);
+		}
+
+		public void AddBestActions(int[] actions)
+		{
+			ActionOptimization.AddBestActions(new ActionDistribution[] { this }, new double[] { 1 }, actions);
+		}
+
+		public static ActionDistribution Combine(ActionDistribution[] dists, double[] coeffs)
+		{
+			ActionDistribution dist = new ActionDistribution(dists[0].Actions);
+			int e = dist.Fraction.Length;
+			int n = dists.Length;
+			dist.MaxFraction = 0;
+			dist.MaxMPS = 0;
+
+			for(int i = 0; i < n; ++i)
+			{
+				dist.TotalMPS += dists[i].TotalMPS * coeffs[i];
+				dist.TotalEPS += dists[i].TotalEPS * coeffs[i];
+				dist.TotalFraction += dists[i].TotalFraction * coeffs[i];
+				dist.MaxMPS += dists[i].MaxMPS * coeffs[i];
+				dist.MaxFraction += dists[i].MaxFraction * coeffs[i];
+				for (int j = 0; j < e; ++j)
+				{
+					dist.Fraction[j] += dists[i].Fraction[j] * coeffs[i];
+					dist.EPS[j] += dists[i].EPS[j] * coeffs[i];
+					dist.MPS[j] += dists[i].MPS[j] * coeffs[i];
+				}
+			}
+			return dist;
+		}
+	}
+
+	// sum f[i] * mps[i] < maxmps
+	// f[i] <= 1 / cooldown[i]
+	// f[proc] <= f[generator] * k
+	//     k * f[generator] - f[proc] >= 0
+	// sum(i in segment) f[i] <= segmenttime
+	// lifebloom + tankdh >= something
+
+	// based on Rawr.Mage.Heap
+	public class DoubleMaxHeap<T>
+	{
+		private int cap;
+		private double[] keys;
+		private T[] values;
+		private int mCount;
+
+		public DoubleMaxHeap(int capacity = 16)
+		{
+			this.cap = capacity;
+			this.keys = new double[this.cap + 1];
+			this.values = new T[this.cap + 1];
+		}
+
+		public void Clear()
+		{
+			this.mCount = 0;
+		}
+
+		public void Pop()
+		{
+			if (mCount == 0)
+				return;
+			double insertKey = keys[mCount];
+			T insertValue = values[mCount];
+			--mCount;
+			int i = 1;
+			while ((i << 1) <= mCount)
+			{
+				int maxChild = i << 1;
+				if (((maxChild + 1) <= mCount) && keys[maxChild + 1] > keys[maxChild])
+					++maxChild;
+				if (insertKey >= keys[maxChild])
+					break;
+				keys[i] = keys[maxChild];
+				values[i] = values[maxChild];
+				i = maxChild;
+			}
+			keys[i] = insertKey;
+			values[i] = insertValue;
+		}
+
+		public void Push(double key, T value)
+		{
+			if (this.mCount == cap)
+			{
+				cap *= 2;
+				double[] newKeys = new double[cap + 1];
+				T[] newValues = new T[cap + 1];
+				Array.Copy(values, newValues, values.Length);
+				Array.Copy(keys, newKeys, keys.Length);
+				keys = newKeys;
+				values = newValues;
+			}
+			this.mCount++;
+			int i = this.mCount;
+			while ((i > 1) && keys[i >> 1] < key)
+			{
+				keys[i] = keys[i >> 1];
+				values[i] = values[i >> 1];
+				i >>= 1;
+			}
+			keys[i] = key;
+			values[i] = value;
+		}
+
+		public int Count
+		{
+			get
+			{
+				return this.mCount;
+			}
+		}
+
+		public double TopKey
+		{
+			get
+			{
+				return keys[1];
+			}
+		}
+
+		public T TopValue
+		{
+			get
+			{
+				return values[1];
+			}
+		}
+	}
+
+	public class ActionOptimization
+	{
+		private static double ccw(double x1, double y1, double x2, double y2, double x3, double y3)
+		{
+			return (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1);
+		}
+
+		// clockwise left-to-right excluding left vertical collinear points if any
+		public static int[] FindUpperIncreasingConvexHullPoints(double[] x, double[] y)
+		{
+			if (x.Length != y.Length)
+				return null;
+			int n = x.Length;
+			if (x.Length == 0)
+				return new int[0];
+			int[] points = new int[n];
+			int npoints = 0;
+			int[] idx = new int[n];
+
+			for (int i = 0; i < n; ++i)
+				idx[i] = i;
+
+			Array.Sort((double[])x.Clone(), idx);
+
+			{
+				int i;
+				double minX = x[idx[0]];
+				double lastY = y[idx[0]];
+				points[npoints++] = idx[0];
+				for (i = 1; i < n; ++i)
+				{
+					int cidx = idx[i];
+					double cx = x[cidx];
+					if(cx != minX)
+						break;
+
+					double cy = y[cidx];
+					if (cy > lastY)
+					{
+						points[0] = cidx;
+						lastY = cy;
+					}
+				}
+				
+				for (; i < n; ++i)
+				{
+					int cidx = idx[i];
+					double cx = x[cidx];
+					double cy = y[cidx];
+
+					if (cy <= lastY)
+						continue;
+
+					while (npoints > 1)
+					{
+						int a = points[npoints - 2];
+						int b = points[npoints - 1];
+						if (ccw(x[a], y[a], x[b], y[b], cx, cy) >= 0)
+							--npoints;
+						else
+							break;
+					}
+					lastY = cy;
+					points[npoints++] = cidx;
+				}
+			}
+			if (npoints == n)
+				return points;
+
+			int[] cpoints = new int[npoints];
+			Array.Copy(points, cpoints, npoints);
+			return cpoints;
+		}
+
+		/* PROBLEM DESCRIPTION:
+		 * We have a set budget, that we need to split between agents who can divide their time between a set of actions, to maximize the resulting gain.
+		 * Must contain a 0 cost action in each set
+		 * 
+		 * OUTPUT:
+		 * selections[] is the selected action for each agent
+		 * if interpSet is >= 0, then it denotes the only agent that splits its time between actions: (1 - interpT) time doing selections[interpSet] and interpT time doing interpTarget
+		 */
+		public static void FindBestBudgetSplit(double[][] costs, double[][] gains, double budget, out int[] selections, out int interpSet, out double interpT, out int interpTarget)
+		{
+			int n = costs.Length;
+			double[][] hgains = new double[n][];
+			double[][] hcosts = new double[n][];
+			int[][] hulls = new int[n][];
+
+			for (int i = 0; i < costs.Length; ++i)
+			{
+				int[] hull = FindUpperIncreasingConvexHullPoints(costs[i], gains[i]);
+				double[] chcosts = new double[hull.Length];
+				double[] chgains = new double[hull.Length];
+
+				for (int j = 0; j < hull.Length; ++j)
+				{
+					chcosts[j] = costs[i][hull[j]];
+					chgains[j] = gains[i][hull[j]];
+				}
+				hgains[i] = chgains;
+				hcosts[i] = chcosts;
+				hulls[i] = hull;
+			}
+
+			DoubleMaxHeap<int> pq = new DoubleMaxHeap<int>();
+			int[] cursors = new int[n];
+
+			for (int i = 0; i < n; ++i)
+			{
+				int cur = 0;
+				if (hgains[i].Length > (cur + 1))
+					pq.Push((hgains[i][cur + 1] - hgains[i][cur]) / (hcosts[i][cur + 1] - hcosts[i][cur]), i);
+			}
+
+			interpSet = -1;
+			interpT = 0;
+			interpTarget = -1;
+
+			while (pq.Count > 0 && budget > 0)
+			{
+				int i = pq.TopValue;
+				pq.Pop();
+
+				int cur = cursors[i];
+				double deltacost = hcosts[i][cur + 1] - hcosts[i][cur];
+				if (deltacost < budget)
+				{
+					budget -= deltacost;
+					++cur;
+					cursors[i] = cur;
+					if (hgains[i].Length > (cur + 1))
+						pq.Push((hgains[i][cur + 1] - hgains[i][cur]) / (hcosts[i][cur + 1] - hcosts[i][cur]), i);
+				}
+				else
+				{
+					interpSet = i;
+					interpT = budget / deltacost;
+					interpTarget = hulls[i][cur + 1];
+					break;
+				}
+			}
+
+			selections = new int[n];
+			for (int i = 0; i < n; ++i)
+				selections[i] = hulls[i][cursors[i]];
+		}
+
+		public static void FindBestActions(Action[][] actionSets, double[] factors, int[] actions, double mpsLeft, out int[] selectedActions, out int interpSet, out double interpT, out int interpTargetAction)
+		{
+			int n = actionSets.Length;
+			double[][] amps = new double[n][];
+			double[][] aeps = new double[n][];
+			for (int i = 0; i < n; ++i)
+			{
+				double[] mps = new double[actions.Length + 1];
+				double[] eps = new double[actions.Length + 1];
+				for (int j = 0; j < actions.Length; ++j)
+				{
+					mps[j] = actionSets[i][actions[j]].MPS * factors[i];
+					eps[j] = actionSets[i][actions[j]].EPS * factors[i];
+				}
+				mps[actions.Length] = 0;
+				eps[actions.Length] = 0;
+				aeps[i] = eps;
+				amps[i] = mps;
+			}
+			int[] selections;
+			int interpTarget;
+
+			FindBestBudgetSplit(amps, aeps, mpsLeft, out selections, out interpSet, out interpT, out interpTarget);
+
+			selectedActions = new int[n];
+			for (int i = 0; i < n; ++i)
+			{
+				if (selections[i] >= actions.Length || actionSets[i][actions[selections[i]]].EPS == 0)
+					selectedActions[i] = -1;
+				else
+					selectedActions[i] = actions[selections[i]];
+			}
+
+			if (interpSet < 0 || interpTarget >= actions.Length || actionSets[interpSet][actions[interpTarget]].EPS == 0)
+				interpTargetAction = -1;
+			else
+				interpTargetAction = actions[interpTarget];
+		}
+
+		public static void FindBestActions(ActionDistribution[] dists, double[] factors, int[] actions, out int[] selectedActions, out int interpSet, out double interpT, out int interpTargetAction)
+		{
+			int n = dists.Length;
+			Action[][] actionSets = new Action[n][];
+			double mpsLeft = 0.0;
+			double[] newFactors = new double[n];
+			for (int i = 0; i < n; ++i)
+			{
+				actionSets[i] = dists[i].Actions;
+				newFactors[i] = factors[i] * (dists[i].MaxFraction - dists[i].TotalFraction);
+				mpsLeft += (dists[i].MaxMPS - dists[i].TotalMPS) * factors[i];
+			}
+
+			FindBestActions(actionSets, newFactors, actions, mpsLeft, out selectedActions, out interpSet, out interpT, out interpTargetAction);
+		}
+
+		public static void AddBestActions(ActionDistribution[] dists, double[] factors, int[] actions)
+		{
+			int[] selectedActions;
+			int interpSet;
+			double interpT;
+			int interpTargetAction;
+			
+			FindBestActions(dists, factors, actions, out selectedActions, out interpSet, out interpT, out interpTargetAction);
+
+			for (int i = 0; i < dists.Length; ++i)
+			{
+				double maxMPS = dists[i].MaxMPS;
+				dists[i].MaxMPS = double.PositiveInfinity;
+				double fractionLeft = dists[i].MaxFraction - dists[i].TotalFraction;
+				if (i == interpSet)
+				{
+					if (selectedActions[i] >= 0)
+						dists[i].AddAction(selectedActions[i], (1 - interpT) * fractionLeft);
+					if (interpTargetAction >= 0)
+						dists[i].AddAction(interpTargetAction, interpT * fractionLeft);
+				}
+				else if (selectedActions[i] >= 0)
+					dists[i].AddAction(selectedActions[i], fractionLeft);
+				
+				dists[i].MaxMPS = maxMPS;
+			}
+		}
+
+		public static void AddBestActions(ActionDistribution[] dists, double[] factors, int[] actions, double unevenPart)
+		{
+			if (unevenPart < 1)
+			{
+				for (int i = 0; i < dists.Length; ++i)
+				{
+					double maxMPS = dists[i].MaxMPS;
+					dists[i].MaxMPS = dists[i].TotalMPS * unevenPart + maxMPS * (1 - unevenPart);
+					dists[i].AddBestActions(actions);
+				}
+			}
+
+			if(unevenPart > 0)
+				AddBestActions(dists, factors, actions);
+		}
+	}
+}
Index: Rawr.Tree/CalculationOptionsTree.cs
===================================================================
--- Rawr.Tree/CalculationOptionsTree.cs	(revision 60557)
+++ Rawr.Tree/CalculationOptionsTree.cs	(working copy)
@@ -6,237 +6,253 @@
 using System.Xml.Serialization;
 
 namespace Rawr.Tree {
+    public class CalculationOptionsTree : ICalculationOptionBase, INotifyPropertyChanged {
+	public string GetXml()
+	{
+		XmlSerializer serializer = new XmlSerializer(typeof(CalculationOptionsTree));
+		StringBuilder xml = new StringBuilder();
+		StringWriter writer = new StringWriter(xml);
+		serializer.Serialize(writer, this);
+		return xml.ToString();
+	}
 
-    public class SpellProfile
-    {
-        private string name;
-        //private int fightDuration; // In seconds - currently hardcoded. To be changed to an input.
-        private int replenishmentUptime; //Should always either be 100% or 0%.
-        private int wildGrowthPerMinute; //Deprecated
-        private int innervates; //comes from form - either 1 or 0
+	public CalculationOptionsTree()
+	{
+        }
 
-        private int swiftmendPerMinute; //Deprecated
-        private int idleCastTimePercent; // goes from 0 to 100 - we should be getting this from the form
-        private int rejuvFrac, regrowthFrac, lifebloomFrac, nourishFrac; //(whole number out of 100, divided by 100 at the second level of assignment)% of the time you use these spells... relates to <name>CF variables elsewhere. These should be inputs.
-        private int rejuvAmount, regrowthAmount, lifebloomStackAmount; //(decimal out of 1)%<name>Amount seems to reference the managedCF variables - unknown difference from regualr CF variables. This is NEVER used without the above variables... Are these double-dipping? Key is in simulateHealing.
-        private int lifebloomStackType; //Slow, Fast, Slow2, Fast2, Rolling
-        private int nourish1, nourish2, nourish3, nourish4; //Nourish with 1-4 HoTs applied.
-        private int livingSeedEfficiency; //% Efficiency of Living Seed - Does this belong here?
-        //private int revitalizePPM;
+	public bool Notify = true;
 
-        private int adjTimeRejuv, adjTimeRegrowth, adjTimeNourish, adjTimeLifebloom; //Not very usefull at the moment... all set to 100% and then applied multiplicitively to the Frac variables...
-        private int adjTimeSwiftmend, adjTimeWildGrowth, adjTimeIdle; ////Not very usefull at the moment... all set to 100% and then applied multiplicitively to the Frac variables...
+	private float tankRatio = 0.05f;
+	public float TankRatio
+	{
+		get { return tankRatio; }
+		set { tankRatio = value; OnPropertyChanged("TankRatio"); }
+	}
 
-        private int adjTimeManagedRejuv, adjTimeManagedRegrowth,
-        adjTimeManagerLifebloomStack; //Not very usefull at the moment... all set to 100% and then applied multiplicitively to the Frac variables...
+	private float raidBurstRatio = 0.05f;
+	public float RaidBurstRatio
+	{
+		get { return raidBurstRatio; }
+		set { raidBurstRatio = value; OnPropertyChanged("RaidBurstRatio"); }
+	}
 
-        private int adjTimeRejuvOrder, adjTimeRegrowthOrder, adjTimeNourishOrder, adjTimeLifebloomOrder; // This sets the precedence that these spells are used in the healing simulator.
+	private float tankBurstRatio = 0.20f;
+	public float TankBurstRatio
+	{
+		get { return tankBurstRatio; }
+		set { tankBurstRatio = value; OnPropertyChanged("TankBurstRatio"); }
+	}
 
-        private int adjTimeSwiftmendOrder, adjTimeWildGrowthOrder, adjTimeIdleOrder; // All of the spells are first, then wildgrowth, then swiftmend, then the 'managed' spells... (Idle is last.)
-        private int adjTimeManagedRejuvOrder, adjTimeManagedRegrowthOrder, adjTimeManagerLifebloomStackOrder; // These are never used except once, and incorrectly. I'm setting them all to 0 until I decide if I should remove them.
+	private bool restoration = true;
+	public bool Restoration
+	{
+		get { return restoration; }
+		set { restoration = value; OnPropertyChanged("Restoration"); }
+	}
 
-        // Adjust for mana
-        private int reduceOOMRejuv, reduceOOMRegrowth, reduceOOMLifebloom,
-        reduceOOMNourish, reduceOOMWildGrowth; // Unknown... Perhaps the amount you reduce usage by when OOM? Goes through a similar process to ensure the values add to 100%...
+	private bool timedInnervates = true;
+	public bool TimedInnervates
+	{
+		get { return timedInnervates; }
+		set { timedInnervates = value; OnPropertyChanged("TimedInnervates"); }
+	}
 
-        private int reduceOOMRejuvOrder, reduceOOMRegrowthOrder, reduceOOMLifebloomOrder, reduceOOMNourishOrder, reduceOOMWildGrowthOrder; // Should be an input. What order you stop using spells in when going OOM. Defaults should be most efficient.
+	private bool innervateOther = false;
+	public bool InnervateOther
+	{
+		get { return innervateOther; }
+		set { innervateOther = value; OnPropertyChanged("InnervateOther"); }
+	}
 
-        public SpellProfile()
-        {
-            name = "Custom";
+	private int externalInnervateSize = 0;
+	public int ExternalInnervateSize
+	{
+		get { return externalInnervateSize; }
+		set { externalInnervateSize = value; OnPropertyChanged("ExternalInnervateSize"); }
+	}
 
-//            FightDuration = 300; // 5 Minutes  // Moved to bosshandler logic
-            ReplenishmentUptime = 100; // Should be an input... Leave at 100% for now. 
-            Innervates = 1; // Overwritten by input. 1 = use your own innervate, 0 = don't use it.
+	private bool separateHasteEffects = false;
+	public bool SeparateHasteEffects
+	{
+		get { return separateHasteEffects; }
+		set { separateHasteEffects = value; OnPropertyChanged("SeparateHasteEffects"); }
+	}
 
-            IdleCastTimePercent = 0;
+	private float lifebloomWastedDuration = 0.5f;
+	public float LifebloomWastedDuration
+	{
+		get { return lifebloomWastedDuration; }
+		set { lifebloomWastedDuration = value; OnPropertyChanged("LifebloomWastedDuration"); }
+	}
 
-            RejuvFrac = 40;  // These should all be overwritten from the form.
-            RegrowthFrac = 0; // These should all be overwritten from the form. 
-            LifebloomFrac = 20; // These should all be overwritten from the form.
-            NourishFrac = 40; // These should all be overwritten from the form.
-            LifebloomStackAmount = 0; // These should all be overwritten from the form.
-            RejuvAmount = 0;
-            RegrowthAmount = 0;
-            LifebloomStackType = 3;  // These should all be overwritten from the form.
-            Nourish1 = 60; // These should be calculated from the relative fractions given above
-            Nourish2 = 10;
-            Nourish3 = 0;
-            Nourish4 = 0;
-            WildGrowthPerMinute = 4; // Currently just a proxy for the cast fractions used by other variables.
-            SwiftmendPerMinute = 2; // Same as WGPM...  Should these two be set seperately and the other cast fractions adjusted to allow?
-            LivingSeedEfficiency = 40; // May need updating.
-                      
-            AdjustTimeRejuv = 100; // Are these useful?
-            AdjustTimeRegrowth = 100; // <--
-            AdjustTimeNourish = 100; // <--
-            AdjustTimeLifebloom = 100; // <--
-            AdjustTimeSwiftmend = 100; // <--
-            AdjustTimeWildGrowth = 100; // <--
-            AdjustTimeIdle = 100; // <--
-            AdjustTimeManagedRejuv = 100; // <--
-            AdjustTimeManagedRegrowth = 100; // <--
-            AdjustTimeManagedLifebloomStack = 100; // <--
-            
-            AdjustTimeRejuvOrder = 0; // These have to all be the same so the balancing works correctly as written.
-            AdjustTimeRegrowthOrder = 0;
-            AdjustTimeNourishOrder = 0;
-            AdjustTimeLifebloomOrder = 0;
-            AdjustTimeSwiftmendOrder = 0;
-            AdjustTimeWildGrowthOrder = 0;
-            AdjustTimeIdleOrder = 1; // I left idle seperate because it needs to be balanced to fill.
-            AdjustTimeManagedRejuvOrder = 3; // These three are of questionable usefulness.
-            AdjustTimeManagedRegrowthOrder = 3;
-            AdjustTimeManagedLifebloomStackOrder = 3;
+	private float wildGrowthCastDelay = 1.0f;
+	public float WildGrowthCastDelay
+	{
+		get { return wildGrowthCastDelay; }
+		set { wildGrowthCastDelay = value; OnPropertyChanged("WildGrowthCastDelay"); }
+	}
 
-            ReduceOOMRejuv = 40; //Are these proptions necessary?
-            ReduceOOMNourish = 80; //Shouldn't we just cut out inefficiencies to prevent going OOM?
-            ReduceOOMLifebloom = 100;
-            ReduceOOMRegrowth = 100;
-            ReduceOOMWildGrowth = 40;
+	private float swiftmendCastDelay = 1.0f;
+	public float SwiftmendCastDelay
+	{
+		get { return swiftmendCastDelay; }
+		set { swiftmendCastDelay = value; OnPropertyChanged("SwiftmendCastDelay"); }
+	}
+	
+	private float naturesSwiftnessCastDelay = 5.0f;
+	public float NaturesSwiftnessCastDelay
+	{
+		get { return naturesSwiftnessCastDelay; }
+		set { naturesSwiftnessCastDelay = value; OnPropertyChanged("NaturesSwiftnessCastDelay"); }
+	}
 
-            ReduceOOMNourishOrder = 4; // This order is questionable.. depends on the fight.
-            ReduceOOMLifebloomOrder = 2; // Perhaps these should be user-definable?
-            ReduceOOMRegrowthOrder = 0;
-            ReduceOOMWildGrowthOrder = 1;
-            ReduceOOMRejuvOrder = 3;
+	private float tranquilityCastDelay = 5.0f;
+	public float TranquilityCastDelay
+	{
+		get { return tranquilityCastDelay; }
+		set { tranquilityCastDelay = value; OnPropertyChanged("TranquilityCastDelay"); }
+	}
 
-//            revitalizePPM = 5; // Should this be an input?  You can only assume perfect proc rates while chain casting...
-        }
-        public SpellProfile Clone()
-        {
-            // Yes, dirty trick. Works.
-            using (Stream objectStream = new MemoryStream())
-            {
-                XmlSerializer serializer = new XmlSerializer(typeof(SpellProfile));
-                serializer.Serialize(objectStream, this);
-                objectStream.Seek(0, SeekOrigin.Begin);
-                return (SpellProfile)serializer.Deserialize(objectStream);
-            }
-        }
-        public string GetXml()
-        {
-            XmlSerializer serializer = new XmlSerializer(typeof(CalculationOptionsTree));
-            StringBuilder xml = new StringBuilder();
-            StringWriter writer = new StringWriter(xml);
-            serializer.Serialize(writer, this);
-            return xml.ToString();
-        }
-        public override string ToString()
-        {
-            return Name;
-        }
+	private float glyphOfRegrowthExtraDuration = 2.0f;
+	public float GlyphOfRegrowthExtraDuration
+	{
+		get { return glyphOfRegrowthExtraDuration; }
+		set { glyphOfRegrowthExtraDuration = value; OnPropertyChanged("GlyphOfRegrowthExtraDuration"); }
+	}
 
-        public string Name { get { return name; } set { name = value; OnPropertyChanged("Name"); } }
-//        public int FightDuration { get { return fightDuration; } set { fightDuration = value; OnPropertyChanged("FightDuration"); } }
-        public int ReplenishmentUptime { get { return replenishmentUptime; } set { replenishmentUptime = value; OnPropertyChanged("ReplenishmentUptime" ); } }
-        public int WildGrowthPerMinute { get { return wildGrowthPerMinute; } set { wildGrowthPerMinute = value; OnPropertyChanged("WildGrowthPerMinute" ); } }
-        public int Innervates          { get { return innervates;          } set { innervates          = value; OnPropertyChanged("Innervates"          ); } }
-        public int SwiftmendPerMinute  { get { return swiftmendPerMinute;  } set { swiftmendPerMinute  = value; OnPropertyChanged("SwiftmendPerMinute"  ); } }
-        public int IdleCastTimePercent { get { return idleCastTimePercent; } set { idleCastTimePercent = value; OnPropertyChanged("IdleCastTimePercent"); } }
+	private bool tankRaidHealing;
+	public bool TankRaidHealing
+	{
+		get { return tankRaidHealing; }
+		set { tankRaidHealing = value; OnPropertyChanged("TankRaidHealing"); }
+	}
 
-        public int RejuvFrac { get { return rejuvFrac; } set { rejuvFrac = value; OnPropertyChanged("RejuvFrac"); } }
-        public int RegrowthFrac { get { return regrowthFrac; } set { regrowthFrac = value; OnPropertyChanged("RegrowthFrac"); } }
-        public int LifebloomFrac { get { return lifebloomFrac; } set { lifebloomFrac = value; OnPropertyChanged("LifebloomFrac"); } }
-        public int NourishFrac { get { return nourishFrac; } set { nourishFrac = value; OnPropertyChanged("NourishFrac"); } }
-        public int LifebloomStackAmount { get { return lifebloomStackAmount; } set { lifebloomStackAmount = value; OnPropertyChanged("AverageLifebloomStack"); } }
-        public int RejuvAmount { get { return rejuvAmount; } set { rejuvAmount = value; OnPropertyChanged("RejuvAmount"); } }
-        public int RegrowthAmount { get { return regrowthAmount; } set { regrowthAmount = value; OnPropertyChanged("RegrowthAmount"); } }
-        public int LifebloomStackType { get { return lifebloomStackType; } set { lifebloomStackType = value; OnPropertyChanged("LifebloomStackType"); } }
+	private bool tankSwiftmend = true;
+	public bool TankSwiftmend
+	{
+		get { return tankSwiftmend; }
+		set { tankSwiftmend = value; OnPropertyChanged("TankSwiftmend"); }
+	}
 
-        public int Nourish1 { get { return nourish1; } set { nourish1 = value; OnPropertyChanged("Nourish1"); } }
-        public int Nourish2 { get { return nourish2; } set { nourish2 = value; OnPropertyChanged("Nourish2"); } }
-        public int Nourish3 { get { return nourish3; } set { nourish3 = value; OnPropertyChanged("Nourish3"); } }
-        public int Nourish4 { get { return nourish4; } set { nourish4 = value; OnPropertyChanged("Nourish4"); } }
+	private bool tankWildGrowth;
+	public bool TankWildGrowth
+	{
+		get { return tankWildGrowth; }
+		set { tankWildGrowth = value; OnPropertyChanged("TankWildGrowth"); }
+	}
 
-        public int AdjustTimeRejuv { get { return adjTimeRejuv; } set { adjTimeRejuv = value; OnPropertyChanged("AdjustTimeRejuv"); } }
-        public int AdjustTimeRegrowth { get { return adjTimeRegrowth; } set { adjTimeRegrowth = value; OnPropertyChanged("AdjustTimeRegrowth"); } }
-        public int AdjustTimeNourish { get { return adjTimeNourish; } set { adjTimeNourish = value; OnPropertyChanged("AdjustTimeNourish"); } }
-        public int AdjustTimeLifebloom { get { return adjTimeLifebloom; } set { adjTimeLifebloom = value; OnPropertyChanged("AdjustTimeLifebloom"); } }
-        public int AdjustTimeSwiftmend { get { return adjTimeSwiftmend; } set { adjTimeSwiftmend = value; OnPropertyChanged("AdjustTimeSwiftmend"); } }
-        public int AdjustTimeWildGrowth { get { return adjTimeWildGrowth; } set { adjTimeWildGrowth = value; OnPropertyChanged("AdjustTimeWildGrowth"); } }
-        public int AdjustTimeIdle { get { return adjTimeIdle; } set { adjTimeIdle = value; OnPropertyChanged("AdjustTimeIdle"); } }
-        public int AdjustTimeManagedRejuv { get { return adjTimeManagedRejuv; } set { adjTimeManagedRejuv = value; OnPropertyChanged("AdjustTimeManagedRejuv"); } }
-        public int AdjustTimeManagedRegrowth { get { return adjTimeManagedRegrowth; } set { adjTimeManagedRegrowth = value; OnPropertyChanged("AdjustTimeManagedRegrowth"); } }
-        public int AdjustTimeManagedLifebloomStack { get { return adjTimeManagerLifebloomStack; } set { adjTimeManagerLifebloomStack = value; OnPropertyChanged("AdjustTimeManagedLifebloomStack"); } }
+	private bool refreshLifebloomWithDirectHeals;
+	public bool RefreshLifebloomWithDirectHeals
+	{
+		get { return refreshLifebloomWithDirectHeals; }
+		set { refreshLifebloomWithDirectHeals = value; OnPropertyChanged("RefreshLifebloomWithDirectHeals"); }
+	}
 
-        public int AdjustTimeRejuvOrder { get { return adjTimeRejuvOrder; } set { adjTimeRejuvOrder = value; OnPropertyChanged("AdjustTimeRejuvOrder"); } }
-        public int AdjustTimeRegrowthOrder { get { return adjTimeRegrowthOrder; } set { adjTimeRegrowthOrder = value; OnPropertyChanged("AdjustTimeRegrowthOrder"); } }
-        public int AdjustTimeNourishOrder { get { return adjTimeNourishOrder; } set { adjTimeNourishOrder = value; OnPropertyChanged("AdjustTimeNourishOrder"); } }
-        public int AdjustTimeLifebloomOrder { get { return adjTimeLifebloomOrder; } set { adjTimeLifebloomOrder = value; OnPropertyChanged("AdjustTimeLifebloomOrder"); } }
-        public int AdjustTimeSwiftmendOrder { get { return adjTimeSwiftmendOrder; } set { adjTimeSwiftmendOrder = value; OnPropertyChanged("AdjustTimeSwiftmendOrder"); } }
-        public int AdjustTimeWildGrowthOrder { get { return adjTimeWildGrowthOrder; } set { adjTimeWildGrowthOrder = value; OnPropertyChanged("AdjustTimeWildGrowthOrder"); } }
-        public int AdjustTimeIdleOrder { get { return adjTimeIdleOrder; } set { adjTimeIdleOrder = value; OnPropertyChanged("AdjustTimeIdleOrder"); } }
-        public int AdjustTimeManagedRejuvOrder { get { return adjTimeManagedRejuvOrder; } set { adjTimeManagedRejuvOrder = value; OnPropertyChanged("AdjustTimeManagedRejuvOrder"); } }
-        public int AdjustTimeManagedRegrowthOrder { get { return adjTimeManagedRegrowthOrder; } set { adjTimeManagedRegrowthOrder = value; OnPropertyChanged("AdjustTimeManagedRegrowthOrder"); } }
-        public int AdjustTimeManagedLifebloomStackOrder { get { return adjTimeManagerLifebloomStackOrder; } set { adjTimeManagerLifebloomStackOrder = value; OnPropertyChanged("AdjustTimeManagedLifebloomStackOrder"); } }
+	private bool rejuvenationTankDuringRaid;
+	public bool RejuvenationTankDuringRaid
+	{
+		get { return rejuvenationTankDuringRaid; }
+		set { rejuvenationTankDuringRaid = value; OnPropertyChanged("RejuvenationTankDuringRaid"); }
+	}
 
-        public int ReduceOOMRejuv { get { return reduceOOMRejuv; } set { reduceOOMRejuv = value; OnPropertyChanged("ReduceOOMRejuv"); } }
-        public int ReduceOOMRegrowth { get { return reduceOOMRegrowth; } set { reduceOOMRegrowth = value; OnPropertyChanged("ReduceOOMRegrowth"); } }
-        public int ReduceOOMLifebloom { get { return reduceOOMLifebloom; } set { reduceOOMLifebloom = value; OnPropertyChanged("ReduceOOMLifebloom"); } }
-        public int ReduceOOMNourish { get { return reduceOOMNourish; } set { reduceOOMNourish = value; OnPropertyChanged("ReduceOOMNourish"); } }
-        public int ReduceOOMWildGrowth { get { return reduceOOMWildGrowth; } set { reduceOOMWildGrowth = value; OnPropertyChanged("ReduceOOMWildGrowth"); } }
+	private float efflorescenceTargets = 2.0f;
+	public float EfflorescenceTargets
+	{
+		get { return efflorescenceTargets; }
+		set { efflorescenceTargets = value; OnPropertyChanged("EfflorescenceTargets"); }
+	}
 
-        public int ReduceOOMRejuvOrder { get { return reduceOOMRejuvOrder; } set { reduceOOMRejuvOrder = value; OnPropertyChanged("ReduceOOMRejuvOrder"); } }
-        public int ReduceOOMRegrowthOrder { get { return reduceOOMRegrowthOrder; } set { reduceOOMRegrowthOrder = value; OnPropertyChanged("ReduceOOMRegrowthOrder"); } }
-        public int ReduceOOMLifebloomOrder { get { return reduceOOMLifebloomOrder; } set { reduceOOMLifebloomOrder = value; OnPropertyChanged("ReduceOOMLifebloomOrder"); } }
-        public int ReduceOOMNourishOrder { get { return reduceOOMNourishOrder; } set { reduceOOMNourishOrder = value; OnPropertyChanged("ReduceOOMNourishOrder"); } }
-        public int ReduceOOMWildGrowthOrder { get { return reduceOOMWildGrowthOrder; } set { reduceOOMWildGrowthOrder = value; OnPropertyChanged("ReduceOOMWildGrowthOrder"); } }
+	private float wildGrowthSymbiosisRate = 0.1f;
+	public float WildGrowthSymbiosisRate
+	{
+		get { return wildGrowthSymbiosisRate; }
+		set { wildGrowthSymbiosisRate = value; OnPropertyChanged("WildGrowthSymbiosisRate"); }
+	}
 
-        public int LivingSeedEfficiency { get { return livingSeedEfficiency; } set { livingSeedEfficiency = value; OnPropertyChanged("LivingSeedEfficiency"); } }
-//        public int RevitalizePPM { get { return revitalizePPM; } set { revitalizePPM = value; OnPropertyChanged("RevitalizePPM"); } }
-        
-        #region INotifyPropertyChanged Members
-        private void OnPropertyChanged(string name) {
-            if (PropertyChanged != null) PropertyChanged(this, new PropertyChangedEventArgs(name));
-        }
-        public event PropertyChangedEventHandler PropertyChanged;
-        #endregion
-    }
+	private float wildGrowthEffectiveHealing = 0.8f;
+	public float WildGrowthEffectiveHealing
+	{
+		get { return wildGrowthEffectiveHealing; }
+		set { wildGrowthEffectiveHealing = value; OnPropertyChanged("WildGrowthEffectiveHealing"); }
+	}
 
-    public class CalculationOptionsTree : ICalculationOptionBase, INotifyPropertyChanged {
-        private int singleTarget;
-        private int sustainedTarget;
-        private int survValuePer100; // 100 Survival Points = 1 HPS (Survival Points = Health / (1-ArmorDamage Reduction)
-        private int singleTargetRotation;
-        private bool ignoreNaturesGrace;
-        private int procType;
+	private float tranquilitySymbiosisRate = 0.1f;
+	public float TranquilitySymbiosisRate
+	{
+		get { return tranquilitySymbiosisRate; }
+		set { tranquilitySymbiosisRate = value; OnPropertyChanged("TranquilitySymbiosisRate"); }
+	}
 
-        private List<SpellProfile> profiles;
-        private SpellProfile current;
+	private float raidSTSymbiosisRate = 0.4f;
+	public float RaidSTSymbiosisRate
+	{
+		get { return raidSTSymbiosisRate; }
+		set { raidSTSymbiosisRate = value; OnPropertyChanged("RaidSTSymbiosisRate"); }
+	}
 
-        public CalculationOptionsTree() {
-            SurvValuePer100 = 1; 
+	private float toLLifebloomEffectiveHealing = 0.7f;
+	public float ToLLifebloomEffectiveHealing
+	{
+		get { return toLLifebloomEffectiveHealing; }
+		set { toLLifebloomEffectiveHealing = value; OnPropertyChanged("ToLLifebloomEffectiveHealing"); }
+	}
 
-            singleTarget = 9000;
-            sustainedTarget = 8500;
-            
-            singleTargetRotation = 0;
+	private float rejuvenationEffectiveHealing = 0.7f;
+	public float RejuvenationEffectiveHealing
+	{
+		get { return rejuvenationEffectiveHealing; }
+		set { rejuvenationEffectiveHealing = value; OnPropertyChanged("RejuvenationEffectiveHealing"); }
+	}
 
-            profiles = new List<SpellProfile>();
-            current = new SpellProfile();
+	private float healingTouchEffectiveHealing = 0.85f;
+	public float HealingTouchEffectiveHealing
+	{
+		get { return healingTouchEffectiveHealing; }
+		set { healingTouchEffectiveHealing = value; OnPropertyChanged("HealingTouchEffectiveHealing"); }
+	}
 
-            IgnoreNaturesGrace = true;
-            ProcType = 0;
+	private float nourishEffectiveHealing = 1.0f;
+	public float NourishEffectiveHealing
+	{
+		get { return nourishEffectiveHealing; }
+		set { nourishEffectiveHealing = value; OnPropertyChanged("NourishEffectiveHealing"); }
+	}
 
-        }
-        public string GetXml() {
-            XmlSerializer serializer = new XmlSerializer(typeof(CalculationOptionsTree));
-            StringBuilder xml = new StringBuilder();
-            StringWriter writer = new StringWriter(xml);
-            serializer.Serialize(writer, this);
-            return xml.ToString();
-        }
-        public int SingleTarget { get { return singleTarget; } set { singleTarget = value; OnPropertyChanged("SingleTarget"); } }
-        public int SustainedTarget { get { return sustainedTarget; } set { sustainedTarget = value; OnPropertyChanged("SustainedTarget"); } }
-        public int SurvValuePer100 { get { return survValuePer100; } set { survValuePer100 = value; OnPropertyChanged("SurvValuePer100"); } }
-        public List<SpellProfile> Profiles { get { return profiles; } set { profiles = value; OnPropertyChanged("Profiles"); } }
-        public SpellProfile Current { get { return current; } set { current = value; OnPropertyChanged("Current"); } }
+	private float raidUnevenlyAllocatedFillerMana = 1.0f;
+	public float RaidUnevenlyAllocatedFillerMana
+	{
+		get { return raidUnevenlyAllocatedFillerMana; }
+		set { raidUnevenlyAllocatedFillerMana = value; OnPropertyChanged("RaidUnevenlyAllocatedFillerMana"); }
+	}
 
-        public int SingleTargetRotation { get { return singleTargetRotation; } set { singleTargetRotation = value; OnPropertyChanged("SingleTargetRotation"); } }
-        public bool IgnoreNaturesGrace { get { return ignoreNaturesGrace; } set { ignoreNaturesGrace = value; OnPropertyChanged("IgnoreNaturesGrace"); } }
-        public int ProcType { get { return procType; } set { procType = value; OnPropertyChanged("ProcType"); } }
+	private float tankUnevenlyAllocatedFillerMana = 1.0f;
+	public float TankUnevenlyAllocatedFillerMana
+	{
+		get { return tankUnevenlyAllocatedFillerMana; }
+		set { tankUnevenlyAllocatedFillerMana = value; OnPropertyChanged("TankUnevenlyAllocatedFillerMana"); }
+	}
 
+	private bool harmony = false;
+	public bool Harmony
+	{
+		get { return harmony; }
+		set { harmony = value; OnPropertyChanged("Harmony"); }
+	}
+
+	private double harmonyCoefficient = 0.0125;
+	public double HarmonyCoefficient
+	{
+		get { return harmonyCoefficient; }
+		set { harmonyCoefficient = value; OnPropertyChanged("HarmonyCoefficient"); }
+	}
+
+	private bool crit100Bonus = false;
+	public bool Crit100Bonus
+	{
+		get { return crit100Bonus; }
+		set { crit100Bonus = value; OnPropertyChanged("Crit100Bonus"); }
+	}
+
         #region INotifyPropertyChanged Members
         public event PropertyChangedEventHandler PropertyChanged;
         private void OnPropertyChanged(string name)
Index: Rawr.Tree/CalculationsTree.cs
===================================================================
--- Rawr.Tree/CalculationsTree.cs	(revision 60557)
+++ Rawr.Tree/CalculationsTree.cs	(working copy)
@@ -5,2138 +5,948 @@
 using System.Xml.Serialization;
 
 namespace Rawr.Tree {
-    public class DiminishingReturns
-    {
-        private double C;
-        private double D;
-        private float multiplier;
-        private float factor;
-        public DiminishingReturns(float multiplier, int factor)
-        {
-            C = Math.Pow(multiplier / factor, factor / (factor - 1));
-            D = Math.Pow(C, 1 / factor);
-            this.multiplier = multiplier;
-            this.factor = factor;
-        }
-        public float Cap(float value, float cap)
-        {
-            if (cap >= value) return value;
-            return (float)(cap + multiplier * cap * (Math.Pow(value / cap - 1 + C, 1 / factor) - D));
-        }
-        // DiminishingReturns(multiplier,factor).Cap(value,cap) gives the same result as this function
-        public static float Cap(float value, float cap, float multiplier, int factor)
-        {
-            if (cap >= value) return value;
-            double C = Math.Pow(multiplier / factor, factor / (factor - 1));
-            return (float)(cap + multiplier * cap * (Math.Pow(value / cap - 1 + C, 1 / factor) - Math.Pow(C, 1 / factor)));
-        }
-        // max > cap, adviced is cap < max <= 2*cap
-        public static float CapWithMaximum(float value, float cap, float max)
-        {
-            if (cap >= value) return value;
-            return (value * max - cap * cap) / (value + max - 2 * cap);
-        }
-        // with max = 2 * cap 
-        // This is exactly the same as the one above, actually, but with 2*cap the formula is much simpler
-        public static float CapWithMaximum2(float value, float cap)
-        {
-            if (cap >= value) return value;
-            return cap * (2 - cap/value);
-        }
-        /*
-         * Derivation of Cap:
-         * we want to base on a function like "y = x^(1/n)"
-         * parameters: cap, x, C and D (a constant tbd), n, f (a multiplier)
-         * y'(cap) = 1
-         * y(cap) = cap
-         * y = cap + f * cap * ( (x/cap-1+C)^(1/n) - (C)^(1/n) ) + D
-         * y' = f * (C + x/cap - 1)^(1/n - 1) / n = 1 when x=cap
-         *   1   = f/n * (C)^(1/n-1)
-         *   n/f = (C)^((1-n)/n) 
-         *   C   = (n/f)^(n/(1-n))
-         *   C   = (f/n)^(n/(n-1))
-         * y(cap) = cap
-         *   0   = f * cap * ((x/cap-1+C)^(1/n) - (C)^(1/n)) + D
-         *   0   = f * cap * ((C)^(1/n) - (C)^(1/n)) + D
-         *   0   = D
-         *   
-         * Derivation of CapWithMaximum:
-         * we want to base on a function like "y = max - 1/x"
-         * parameters: cap, max, A and B (a constant tbd)
-         * y'(cap) = 1
-         * y(cap) = cap
-         * limit of x to infinity = max
-         *  .... to be written out eventually
-         * y = (x * max - cap^2) / (x + max - 2*cap)
-         * y' = (max - cap)^2 / (max - 2 * cap + x)^2
-         * y'(cap) = (max - cap)^2 / (max - cap)^2 = 1
-         * y(cap) = (cap * max - cap*cap) / (cap + max - 2 * cap)
-         *        = cap * (max - cap) / (max - cap) = 1
-         * limit of x to infinity:
-         * y = (x * max - cap^2) / (x + max - 2*cap) with x to infinity ==> differentiate top and bottom with respect to x
-         * y = (max) / (1) = max
-         */
-    }
+	enum PointsTree : int
+	{
+		RaidSustained,
+		RaidBurst,
+		TankSustained,
+		TankBurst,
+		Count
+	}
 
-    [Rawr.Calculations.RawrModelInfo("Tree", "Ability_Druid_TreeofLife", CharacterClass.Druid)]
-    public class CalculationsTree : CalculationsBase {
-        private List<GemmingTemplate> _defaultGemmingTemplates = null;
-        public override List<GemmingTemplate> DefaultGemmingTemplates {
-            get {
-                if (_defaultGemmingTemplates == null) {
-                    // Meta
-                    int ember = 52296;
-                    int revitalizing = 52297;
+	[Rawr.Calculations.RawrModelInfo("Tree", "Ability_Druid_TreeofLife", CharacterClass.Druid)]
+	public class CalculationsTree : CalculationsBase
+	{
+		#region Variables and Properties
+		#region Gemming Templates
+		private string[] tierNames = { "Uncommon", "Rare", "Epic", "Jeweler" };
 
-                    // [0] uncommon
-                    // [1] perfect uncommon
-                    // [2] rare
-                    // [3] epic
-                    // [4] jewelcrafting
+		// Red
+		private int[] brilliant = { 52173, 52207, 52207, 52257 };
 
-                    // Reds
-                    int[] runed = { 52084, 52173, 52207, 52207, 52257 }; // int
-                    // Blue
-                    int[] sparkling = { 52087, 52170, 52244, 52244, 52262 }; // spi [pure]
-                    // Yellow
-                    int[] quick = { 52093, 52164, 52232, 52232, 52268 }; // haste [pure]
-                    // Purple
-                    int[] purified = { 52100, 52157, 52236, 52236 }; // int + spirit
-                    // Green
-                    // Zen - Spirit + Mastery = Worthless
-                    // Orange
-                    int[] reckless = { 52113, 52144, 52208, 52208 }; // int + haste
+		// Orange
+		private int[] reckless = { 52144, 52208, 52208, 52208 };
+		private int[] artful = { 52140, 52205, 52205, 52205 };
+		private int[] potent = { 52147, 52239, 52239, 52239 };
 
-                    /*
-                     * Gemmings
-                     * No Crit No MP5, Int > Spirit > Haste > Crit > Mastery
-                     * red: Runed, Purified
-                     * yellow: Quick, Reckless
-                     * blue: Sparkling, Purified
-                     * = runed, purified, reckless, sparkling, quick
-                     * Meta: use ember
-                     */
+		// Purple
+		private int[] purified = { 52100, 52236, 52236, 52236 };
 
-                    _defaultGemmingTemplates = new List<GemmingTemplate>();
-                    AddGemmingTemplateGroup(_defaultGemmingTemplates, "Uncommon (Ember)", false, runed[0], purified[0], reckless[0], ember);
-                    AddGemmingTemplateGroup(_defaultGemmingTemplates, "Uncommon (Revitalizing)", false, runed[0], purified[0], reckless[0], revitalizing);
-                    AddGemmingTemplateGroup(_defaultGemmingTemplates, "Perfect (Ember)", false, runed[1], purified[1], reckless[1], ember);
-                    AddGemmingTemplateGroup(_defaultGemmingTemplates, "Perfect (Revitalizing)", false, runed[1], purified[1], reckless[1], revitalizing);
-                    AddGemmingTemplateGroup(_defaultGemmingTemplates, "Rare (Ember)", false, runed[2], purified[2], reckless[2], ember);
-                    AddGemmingTemplateGroup(_defaultGemmingTemplates, "Rare (Revitalizing)", false, runed[2], purified[2], reckless[2], revitalizing);
-                    AddGemmingTemplateGroup(_defaultGemmingTemplates, "Epic (Ember)", true, runed[3], purified[3], reckless[3], ember);
-                    AddGemmingTemplateGroup(_defaultGemmingTemplates, "Epic (Revitalizing)", true, runed[3], purified[3], reckless[3], revitalizing);
-                    AddJCGemmingTemplateGroup(_defaultGemmingTemplates, "Jewelcrafting (Ember)", false, runed[4], ember);
-                    AddJCGemmingTemplateGroup(_defaultGemmingTemplates, "Jewelcrafting (Revitalizing)", false, runed[4], revitalizing);
-                }
-                return _defaultGemmingTemplates;
-            }
-        }
-        private void AddGemmingTemplateGroup(List<GemmingTemplate> list, string name, bool enabled, int runed, int purified, int reckless, int meta) {
-            // Overrides, only "runed" and "seers"
-            list.Add(new GemmingTemplate() { Model = "Tree", Group = name, RedId = runed, YellowId = runed, BlueId = runed, PrismaticId = runed, MetaId = meta, Enabled = enabled });
-            list.Add(new GemmingTemplate() { Model = "Tree", Group = name, RedId = runed, YellowId = reckless, BlueId = purified, PrismaticId = runed, MetaId = meta, Enabled = enabled });
-        }
-        private void AddJCGemmingTemplateGroup(List<GemmingTemplate> list, string name, bool enabled, int runed, int meta) {
-            list.Add(new GemmingTemplate() { Model = "Tree", Group = name, RedId = runed, YellowId = runed, BlueId = runed, PrismaticId = runed, MetaId = meta, Enabled = enabled });
-        }
+		// Meta
+		private int ember = 52296;
+		private int revitalizing = 52297;
 
-        private static List<string> _relevantGlyphs;
-        public override List<string> GetRelevantGlyphs()
-        {
-            if (_relevantGlyphs == null)
-            {
-                _relevantGlyphs = new List<string>();
-                _relevantGlyphs.Add("Glyph of Healing Touch");
-                _relevantGlyphs.Add("Glyph of Innervate");
-                _relevantGlyphs.Add("Glyph of Lifebloom");
-                //_relevantGlyphs.Add("Glyph of Nourish");
-                _relevantGlyphs.Add("Glyph of Rebirth");
-                _relevantGlyphs.Add("Glyph of Regrowth");
-                _relevantGlyphs.Add("Glyph of Rejuvination");
-                _relevantGlyphs.Add("Glyph of Swiftmend");
-                _relevantGlyphs.Add("Glyph of Wild Growth");
-                //_relevantGlyphs.Add("Glyph of Rapid Rejuvenation");
-            }
-            return _relevantGlyphs;
-        }
-        
-        private Dictionary<string, Color> _subPointNameColors = null;
-        private Dictionary<string, Color> _subPointNameColorsRating = null;
-        private Dictionary<string, Color> _subPointNameColorsMPS = null;
-        private Dictionary<string, Color> _subPointNameColorsHPS = null;
-        private Dictionary<string, Color> _subPointNameColorsHPCT = null;
-        private Dictionary<string, Color> _subPointNameColorsHPM = null;
-        private Dictionary<string, Color> _subPointNameColorsCF = null;
+		//Cogwheel
+		private int cog_fractured = 59480;  //Mastery
+		private int cog_sparkling = 59496;  //Spirit
+		private int cog_quick = 59479;  //Haste
+		private int cog_smooth = 59478;  //Crit
 
-        public CalculationsTree()
-        {
-            _subPointNameColorsRating = new Dictionary<string, Color>();
-            _subPointNameColorsRating.Add("SingleTarget", Color.FromArgb(255, 255, 0, 0));
-            _subPointNameColorsRating.Add("Sustained", Color.FromArgb(255, 0, 0, 255));
-            _subPointNameColorsRating.Add("Survival", Color.FromArgb(255, 0, 128, 0));
+		/// <summary>
+		/// List of gemming templates available to Rawr.
+		/// </summary>
+		public override List<GemmingTemplate> DefaultGemmingTemplates
+		{
+			get
+			{
+				List<GemmingTemplate> retval = new List<GemmingTemplate>();
+				for (int tier = 0; tier < 4; ++tier)
+				{
+					retval.AddRange(TreeGemmingTemplateBlock(tier, ember));
+					retval.AddRange(TreeGemmingTemplateBlock(tier, revitalizing));
+				}
+				retval.AddRange(new GemmingTemplate[] {
+				// Engineering cogwheel templates (meta and 2 cogs each, no repeats)
+				CreateTreeCogwheelTemplate(ember, cog_fractured, cog_quick),
+				CreateTreeCogwheelTemplate(ember, cog_fractured, cog_smooth),
+				CreateTreeCogwheelTemplate(ember, cog_fractured, cog_sparkling),
+				CreateTreeCogwheelTemplate(ember, cog_quick, cog_smooth),
+				CreateTreeCogwheelTemplate(ember, cog_quick, cog_sparkling),
+				CreateTreeCogwheelTemplate(ember, cog_smooth, cog_sparkling),
+				CreateTreeCogwheelTemplate(revitalizing, cog_fractured, cog_quick),
+				CreateTreeCogwheelTemplate(revitalizing, cog_fractured, cog_smooth),
+				CreateTreeCogwheelTemplate(revitalizing, cog_fractured, cog_sparkling),
+				CreateTreeCogwheelTemplate(revitalizing, cog_quick, cog_smooth),
+				CreateTreeCogwheelTemplate(revitalizing, cog_quick, cog_sparkling),
+				CreateTreeCogwheelTemplate(revitalizing, cog_smooth, cog_sparkling),
+				});
+				return retval;
+			}
+		}
 
-            _subPointNameColorsMPS = new Dictionary<string, Color>();
-            _subPointNameColorsMPS.Add("Mana per second", Color.FromArgb(128, 0, 0, 255));
+		private List<GemmingTemplate> TreeGemmingTemplateBlock(int tier, int meta)
+		{
+			List<GemmingTemplate> retval = new List<GemmingTemplate>();
+			retval.AddRange(new GemmingTemplate[]
+                {
+                CreateTreeGemmingTemplate(tier, tierNames, brilliant, brilliant, brilliant, brilliant, meta), // Straight Intellect
+                CreateTreeGemmingTemplate(tier, tierNames, brilliant, reckless, brilliant, brilliant, meta), // Int/Haste/Int
+                CreateTreeGemmingTemplate(tier, tierNames, brilliant, potent, brilliant, brilliant, meta), // Int/Crit/Int
+                CreateTreeGemmingTemplate(tier, tierNames, brilliant, artful, brilliant, brilliant, meta), // Int/Mastery/Int
+                CreateTreeGemmingTemplate(tier, tierNames, brilliant, reckless, purified, brilliant, meta), // Int/Haste/Spirit
+                CreateTreeGemmingTemplate(tier, tierNames, brilliant, potent, purified, brilliant, meta), // Int/Crit/Spirit
+                CreateTreeGemmingTemplate(tier, tierNames, brilliant, artful, purified, brilliant, meta), // Int/Mastery/Spirit
+                });
+			return retval;
+		}
 
-            _subPointNameColorsHPS = new Dictionary<string, Color>();
-            _subPointNameColorsHPS.Add("Healing per second", Color.FromArgb(128, 0, 255, 0));
+		const int DEFAULT_GEMMING_TIER = 1;
+		private GemmingTemplate CreateTreeGemmingTemplate(int tier, string[] tierNames, int[] red, int[] yellow, int[] blue, int[] prismatic, int meta)
+		{
+			return new GemmingTemplate
+			{
+				Model = "Tree",
+				Group = tierNames[tier],
+				Enabled = (tier == DEFAULT_GEMMING_TIER),
+				RedId = red[tier],
+				YellowId = yellow[tier],
+				BlueId = blue[tier],
+				PrismaticId = prismatic[tier],
+				MetaId = meta
+			};
+		}
 
-            _subPointNameColorsHPCT = new Dictionary<string, Color>();
-            _subPointNameColorsHPCT.Add("Healing per cast time", Color.FromArgb(128, 0, 255, 0));
+		private GemmingTemplate CreateTreeCogwheelTemplate(int meta, int cogwheel1, int cogwheel2)
+		{
+			return new GemmingTemplate
+			{
+				Model = "Tree",
+				Group = "Engineering",
+				Enabled = false,
+				MetaId = meta,
+				CogwheelId = cogwheel1,
+				Cogwheel2Id = cogwheel2
+			};
+		}
+		#endregion
 
-            _subPointNameColorsHPM = new Dictionary<string, Color>();
-            _subPointNameColorsHPM.Add("Healing per mana", Color.FromArgb(128, 0, 255, 255));
+		/// <summary>Labels of the stats available to the Optimizer</summary>
+		public override string[] OptimizableCalculationLabels
+		{
+			get
+			{
+				if (_optimizableCalculationLabels == null)
+					_optimizableCalculationLabels = new string[] {
+                    "Spirit",
+                    "Haste Rating",
+                    "Crit Rating",
+                    "Mastery Rating"
+                    };
+				return _optimizableCalculationLabels;
+			}
+		}
+		private string[] _optimizableCalculationLabels = null;
 
-            _subPointNameColorsCF = new Dictionary<string, Color>();
-            _subPointNameColorsCF.Add("Casting time percentage", Color.FromArgb(196, 0, 255, 0));
-            _subPointNameColorsCF.Add("Mana reduction", Color.FromArgb(196, 255, 255, 0));
-            _subPointNameColorsCF.Add("Time reduction", Color.FromArgb(196, 255, 0, 0));
+		public override Dictionary<string, Color> SubPointNameColors
+		{
+			get
+			{
+				if (_subPointNameColors == null)
+				{
+					_subPointNameColors = new Dictionary<string, Color>();
+					
+					_subPointNameColors.Add("Raid Sustained", Colors.Green);
+					_subPointNameColors.Add("Raid Burst", Colors.Yellow);
+					_subPointNameColors.Add("Tank Sustained", Colors.Blue);
+					_subPointNameColors.Add("Tank Burst", Colors.Red);
 
-            _subPointNameColors = _subPointNameColorsRating;
-        }
+				}
+				return _subPointNameColors;
+			}
+		}
+		private Dictionary<string, Color> _subPointNameColors = null;
 
-        public override Dictionary<string, Color> SubPointNameColors {
-            get {
-                Dictionary<string, Color> ret = _subPointNameColors;
-                _subPointNameColors = _subPointNameColorsRating;
-                return ret;
-            }
-        }
+		private string[] characterDisplayCalculationLabels = null;
+		public override string[] CharacterDisplayCalculationLabels
+		{
+			get
+			{
+				if (characterDisplayCalculationLabels != null)
+					return characterDisplayCalculationLabels;
 
-        private string[] _characterDisplayCalculationLabels = null;
-        public override string[] CharacterDisplayCalculationLabels {
-            get {
-                if (_characterDisplayCalculationLabels == null) {
-                    _characterDisplayCalculationLabels = new string[] {
-                        "Points:Single Target Points",
-                        "Points:Sustained Points",
-                        @"Points:Survival Points*Survival Points represents the total raw physical damage 
-you can take before dying. Calculated based on Health
-and Armor damage reduction. (Survival multiplier is 
-applied and result is scaled down by 100)",
-                        "Points:Overall Points",
+				string[] basic = new string[] {
+				    "Basic Stats:Health",
+				    "Basic Stats:Mana",
+				    "Basic Stats:Mean Mana",
+				    "Basic Stats:Innervate Mana",
+				    "Basic Stats:Agility",
+				    "Basic Stats:Stamina",
+				    "Basic Stats:Intellect",
+				    "Basic Stats:Spirit",
+				    "Basic Stats:Armor",
+				    "Spell Stats:Spell Power",
+				    "Spell Stats:Spell Crit",
+				    "Spell Stats:Spell Haste",
+				    "Spell Stats:Symbiosis",
+				    "Spell Stats:Harmony",
+				    "Spell Stats:Spell Mana Cost Reduction",
+				    "Spell Stats:Spell Crit Extra Bonus",
+				    "Mana Regen:Mana Regen",
+    				    "Mana Regen:Initial Mana Pool Regen",
+				    "Mana Regen:Base Mana Regen",
+				    "Mana Regen:Spirit Mana Regen",
+				    "Mana Regen:Replenishment Mana Regen",
+				    "Mana Regen:Revitalize Mana Regen",
+				    "Mana Regen:Innervate Mana Regen",
+				    "Mana Regen:Ext Innervate Mana Regen",
+				    "Mana Regen:Potion Mana Regen",
+				    "Mana Regen:Innervates",
+				    "Fight:Fight Length",
+				    "Fight:Divisions",
+				    "Solution:Total Score",
+				    };
 
-                        "Base Stats:Base Health",
-                        "Base Stats:Base Armor",
-                        "Base Stats:Base Mana",
-                        "Base Stats:Base Stamina",
-                        "Base Stats:Base Intellect",
-                        "Base Stats:Base Spirit",
-                        "Base Stats:Base Spell Power",
-                        "Base Stats:Base Spell Crit",
-                        "Base Stats:Base Spell Haste",
-                        "Base Stats:Base Mastery",
-                        "Base Stats:Base Global CD",
+				List<string> list = new List<string>();
+				list.AddRange(basic);
 
-                        "Combat Stats:Health",
-                        "Combat Stats:Armor",
-                        "Combat Stats:Mana",
-                        "Combat Stats:Stamina",
-                        "Combat Stats:Intellect",
-                        "Combat Stats:Spirit",
-                        "Combat Stats:Spell Power",
-                        "Combat Stats:Spell Crit",
-                        "Combat Stats:Spell Haste",
-                        "Combat Stats:Mastery",
-                        "Combat Stats:Global CD",
+				string[] longNames = { "Raid Sustained", "Raid Burst", "Tank Sustained", "Tank Burst" };
+				string[] names = { "Raid S.", "Raid B.", "Tank S.", "Tank B." };
+				for (int i = 0; i < longNames.Length; ++i)
+					list.Add("Solution:" + longNames[i] + " HPS");
 
-                        "Model:Boss Name",
-                        "Model:Total Time",
-                     //   "Model:Time until OOM (unreduced)",
-                     //   "Model:Time until OOM",
-                        "Model:Total healing done",
-                        "Model:Sustained HPS",
-                        "Model:Single Target HPS",
-                        "Model:Mana regen per second",
-                        "Model:Mana from innervates",
-                        "Model:Average casts per minute",
-                        "Model:Average crits per minute",
-                        "Model:Average heals per minute",
-                        "Model:Rejuvenation casts per minute",
-                        "Model:Rejuvenation average up",
-                        "Model:Regrowth casts per minute",
-                        "Model:Regrowth average up",
-                        "Model:Lifebloom (stack) casts per minute",
-                        "Model:Lifebloom (stack) average up",
-                        "Model:Lifebloom (stack) method",
-                        "Model:Lifebloom casts per minute",
-                        "Model:Lifebloom average up",
-                        "Model:Nourish casts per minute",
-                        //"Model:Healing Touch casts per minute",
-                        "Model:Swiftmend casts per minute",
-                        "Model:Wild Growth casts per minute",
-                        "Model:Revitalize procs per minute",
+				string[] actionNames = new string[(int)TreeAction.Count];
+				for (int i = 0; i < (int)TreeAction.Count; ++i)
+					actionNames[i] = Action.GetName((TreeAction)i);
 
-                        "Rejuvenation:RJ Heal per tick",
-                        "Rejuvenation:RJ Tick time",
-                        "Rejuvenation:RJ HPS",
-                        "Rejuvenation:RJ HPM",
-                        "Rejuvenation:RJ HPCT",
+				for (int i = 0; i < longNames.Length; ++i)
+				{
+					for (int j = 0; j < (int)TreeAction.Count; ++j)
+					{
+						if (names[i].Substring(0, 4) == "Raid" || actionNames[j].Substring(0, 4) == "Tank")
+							list.Add(longNames[i] + ':' + names[i] + ' ' + actionNames[j]);
+					}
+					list.Add(longNames[i] + ':' + names[i] + " Idle");
+				}
 
-                        "Regrowth:RG Heal",
-                        "Regrowth:RG Tick",
-                        "Regrowth:RG HPS",
-                        "Regrowth:RG HPS (HoT only)",
-                        "Regrowth:RG HPM",
-                        "Regrowth:RG HPCT",
-                        "Regrowth:RG Heal (spam)",
-                        "Regrowth:RG HPS (spam)",
-                        "Regrowth:RG HPM (spam)",
-                        "Regrowth:RG HPCT (spam)",
+				for (int i = 0; i < (int)TreeAction.Count; ++i)
+					list.Add("Action HPS:" + actionNames[i] + " HPS");
+				for (int i = 0; i < (int)TreeAction.Count; ++i)
+					list.Add("Action HPM:" + actionNames[i] + " HPM");
+				for (int i = 0; i < (int)TreeAction.Count; ++i)
+					list.Add("Action MPS:" + actionNames[i] + " MPS");
+				characterDisplayCalculationLabels = list.ToArray();
+				
+				return characterDisplayCalculationLabels;
+			}
+		}
 
-                        "Lifebloom:LB Tick",
-                        "Lifebloom:LB Bloom Heal",
-                        "Lifebloom:LB HPS",
-                        "Lifebloom:LB HPS (HoT only)",
-                        "Lifebloom:LB HPM",
-                        "Lifebloom:LB HPCT",
+		public override CharacterClass TargetClass { get { return CharacterClass.Druid; } }
+		public override ICalculationOptionsPanel CalculationOptionsPanel { get { if (calculationOptionsPanel == null) { calculationOptionsPanel = new CalculationOptionsPanelTree(); } return calculationOptionsPanel; } }
+		private ICalculationOptionsPanel calculationOptionsPanel = null;
+		public override ComparisonCalculationBase CreateNewComparisonCalculation() { return new ComparisonCalculationTree(); }
+		public override CharacterCalculationsBase CreateNewCharacterCalculations() { return new CharacterCalculationsTree(); }
 
-                        "Lifebloom Stacked Blooms:LBx2 (fast stack) HPS",
-                        "Lifebloom Stacked Blooms:LBx2 (fast stack) HPM",
-                        "Lifebloom Stacked Blooms:LBx2 (fast stack) HPCT",
+		public override ICalculationOptionBase DeserializeDataObject(string xml)
+		{
+			System.Xml.Serialization.XmlSerializer serializer =
+			    new System.Xml.Serialization.XmlSerializer(typeof(CalculationOptionsTree));
+			System.IO.StringReader reader = new System.IO.StringReader(xml);
+			CalculationOptionsTree calcOpts = serializer.Deserialize(reader) as CalculationOptionsTree;
+			return calcOpts;
+		}
 
-                        "Lifebloom Stacked Blooms:LBx3 (fast stack) HPS",
-                        "Lifebloom Stacked Blooms:LBx3 (fast stack) HPM",
-                        "Lifebloom Stacked Blooms:LBx3 (fast stack) HPCT",
+		#endregion
 
-                        "Lifebloom Stacked Blooms:LBx2 (slow stack) HPS",
-                        "Lifebloom Stacked Blooms:LBx2 (slow stack) HPM",
-                        "Lifebloom Stacked Blooms:LBx2 (slow stack) HPCT",
+		#region Relevancy
+		public override bool EnchantFitsInSlot(Enchant enchant, Character character, ItemSlot slot)
+		{
+			// No enchants allowed on our ranged slot
+			if (slot == ItemSlot.Ranged) return false;
+			// Make an exception for enchant 4091 - Enchant Off-Hand - Superior Intellect
+			if (slot == ItemSlot.OffHand && enchant.Id == 4091) return true;
+			// No other enchants allowed on our offhands
+			if (slot == ItemSlot.OffHand) return false;
+			// Otherwise, return the base value
+			return base.EnchantFitsInSlot(enchant, character, slot);
+		}
 
-                        "Lifebloom Stacked Blooms:LBx3 (slow stack) HPS",
-                        "Lifebloom Stacked Blooms:LBx3 (slow stack) HPM",
-                        "Lifebloom Stacked Blooms:LBx3 (slow stack) HPCT",
+		public override bool ItemFitsInSlot(Item item, Character character, CharacterSlot slot, bool ignoreUnique)
+		{
+			if (slot == CharacterSlot.OffHand && item.Slot == ItemSlot.OneHand) return false;
+			return base.ItemFitsInSlot(item, character, slot, ignoreUnique);
+		}
 
-                        "Lifebloom Stacked Blooms:LBx3 (rolling) Tick",
-                        "Lifebloom Stacked Blooms:LBx3 (rolling) HPS",
-                        "Lifebloom Stacked Blooms:LBx3 (rolling) HPM",
-                        "Lifebloom Stacked Blooms:LBx3 (rolling) HPCT",
+		private static List<string> _relevantGlyphs;
+		public override List<string> GetRelevantGlyphs()
+		{
+			if (_relevantGlyphs == null)
+			{
+				// TODO: implement the commented out glyphs
 
-                        "Healing Touch:HT Heal",
-                        "Healing Touch:HT HPS",
-                        "Healing Touch:HT HPM",
-                        "Healing Touch:HT HPCT",
+				_relevantGlyphs = new List<string>();
+				_relevantGlyphs.Add("Glyph of Lifebloom");
+				_relevantGlyphs.Add("Glyph of Rejuvenation");
+				_relevantGlyphs.Add("Glyph of Swiftmend");
+				_relevantGlyphs.Add("Glyph of Regrowth");
 
-                        "Wild Growth:WG first Tick",
-                        "Wild Growth:WG HPS(single target)",
-                        "Wild Growth:WG HPM(single target)",
-                        "Wild Growth:WG HPS(max)",
-                        "Wild Growth:WG HPM(max)",
+				_relevantGlyphs.Add("Glyph of Wild Growth");
+				_relevantGlyphs.Add("Glyph of Healing Touch");
+				_relevantGlyphs.Add("Glyph of Innervate");
+			}
+			return _relevantGlyphs;
+		}
 
-                        "Nourish:N Heal",
-                        "Nourish:N HPM",
-                        "Nourish:N HPS",
-                        "Nourish:N HPCT",
-                        "Nourish:N (1 HoT) Heal",
-                        "Nourish:N (1 HoT) HPM",
-                        "Nourish:N (1 HoT) HPS",
-                        "Nourish:N (1 HoT) HPCT",
-                        //"Nourish:N (2 HoTs) Heal",
-                        //"Nourish:N (2 HoTs) HPM",
-                        //"Nourish:N (2 HoTs) HPS",
-                        //"Nourish:N (2 HoTs) HPCT",
-                        //"Nourish:N (3 HoTs) Heal",
-                        //"Nourish:N (3 HoTs) HPM",
-                        //"Nourish:N (3 HoTs) HPS",
-                        //"Nourish:N (3 HoTs) HPCT",
-                        //"Nourish:N (4 HoTs) Heal",
-                        //"Nourish:N (4 HoTs) HPM",
-                        //"Nourish:N (4 HoTs) HPS",
-                        //"Nourish:N (4 HoTs) HPCT",
+		/// <summary>
+		/// List of itemtypes that are relevant for Tree
+		/// </summary>
+		private List<ItemType> _relevantItemTypes = null;
+		public override List<ItemType> RelevantItemTypes
+		{
+			get
+			{
+				return _relevantItemTypes ?? (_relevantItemTypes = new List<ItemType>(new ItemType[]
+                {
+                            ItemType.None,
+                            ItemType.Leather,
+                            ItemType.Dagger,
+                            ItemType.Staff,
+                            ItemType.FistWeapon,
+                            ItemType.OneHandMace,
+                            ItemType.TwoHandMace,
+                            ItemType.Idol,
+                            ItemType.Relic,
+                }));
+			}
+		}
 
-                        "Swiftmend:SM Heal",
-                        "Swiftmend:SM HPM",
-                        "Swiftmend:SM Rejuv Lost Ticks",
-                        "Swiftmend:Efflorescence Heal",
-                    };
-                }
-                return _characterDisplayCalculationLabels;
-            }
-        }
 
-        private string[] _customChartNames = null;
-        public override string[] CustomChartNames {
-            get {
-                if (_customChartNames == null) {
-                    _customChartNames = new string[] {
-                        "Single target spell mixes (HPS)",
-                        "Single target spell mixes (HPM)",
-                        "Single target spell mixes (MPS)",
-                        "Healing per spell (single target)",
-                        "Mana sources (sustained)",
-                        "Mana usage per spell (sustained)",
-                        "Total HPS per spell (sustained)",
-                        "Casting time percentage per spell (sustained)",
-                        "HPCT per spell",
-                        "HPS per spell",
-                        "HPM per spell",
-                        "New HPM per rotation",
-                        "New HPS per rotation",
-                        "New MPS per rotation",
+		/// <summary>
+		/// List of SpecialEffect Triggers that are relevant for tree model
+		/// Every trigger listed here needs an implementation in ProcessSpecialEffects()
+		/// A trigger not listed here should not appear in ProcessSpecialEffects()
+		/// </summary>
+		internal static List<Trigger> _RelevantTriggers = null;
+		internal static List<Trigger> RelevantTriggers
+		{
+			get
+			{
+				return _RelevantTriggers ?? (_RelevantTriggers = new List<Trigger>() {
+                            Trigger.Use,
+                            Trigger.HealingSpellCast,
+                            Trigger.HealingSpellCrit,
+                            Trigger.HealingSpellHit,
+                            Trigger.SpellCast,
+                            Trigger.SpellCrit,        
+                            Trigger.SpellHit, 
+                            Trigger.DoTTick,
+                            Trigger.DamageOrHealingDone,
+                        });
+			}
+			//set { _RelevantTriggers = value; }
+		}
 
-                    };
-                }
-                return _customChartNames;
-            }
-        }
+		public override bool IsItemRelevant(Item item)
+		{
+			// First we let normal rules (profession, class, relevant stats) decide
+			bool relevant = base.IsItemRelevant(item);
 
-        private string[] _optimizableCalculationLabels = null;
-        public override string[] OptimizableCalculationLabels {
-            get {
-                if (_optimizableCalculationLabels == null)
-                    _optimizableCalculationLabels = new string[] {
-                        "Mana",
-                        "MP5",
-                        "Global CD",
-                    };
-                return _optimizableCalculationLabels;
-            }
-        }
+			// Next we use our special stat relevancy filtering.
+			if (relevant)
+				relevant = HasPrimaryStats(item.Stats) || (HasSecondaryStats(item.Stats) && !HasUnwantedStats(item.Stats));
 
-        private BossOptions boss = null;
-        private ICalculationOptionsPanel _calculationOptionsPanel = null;
-        public override ICalculationOptionsPanel CalculationOptionsPanel { get { return _calculationOptionsPanel ?? (_calculationOptionsPanel = new CalculationOptionsPanelTree()); } }
+			return relevant;
+		}
 
-        private List<ItemType> _relevantItemTypes = null;
-        public override List<ItemType> RelevantItemTypes {
-            get {
-                if (_relevantItemTypes == null) {
-                    _relevantItemTypes = new List<ItemType>(new ItemType[]{
-                        ItemType.None,
-                        ItemType.Cloth,
-                        ItemType.Leather,
-                        ItemType.Dagger,
-                        ItemType.FistWeapon,
-                        ItemType.Idol, ItemType.Relic,
-                        ItemType.OneHandMace,
-                        ItemType.TwoHandMace,
-                        ItemType.Staff
-                    });
-                }
-                return _relevantItemTypes;
-            }
-        }
+		public override bool IsBuffRelevant(Buff buff, Character character)
+		{
+			// First we let normal rules (profession, class, relevant stats) decide
+			bool relevant = base.IsBuffRelevant(buff, character);
 
-        public override CharacterClass TargetClass { get { return CharacterClass.Druid; } }
-        public override ComparisonCalculationBase CreateNewComparisonCalculation() { return new ComparisonCalculationTree(); }
-        public override CharacterCalculationsBase CreateNewCharacterCalculations() { return new CharacterCalculationsTree(); }
+			// Next we use our special stat relevancy filtering on consumables. (party buffs only need filtering on relevant stats)
+			if (relevant && (buff.Group == "Elixirs and Flasks" || buff.Group == "Potion" || buff.Group == "Food" || buff.Group == "Scrolls" || buff.Group == "Temporary Buffs"))
+				relevant = HasPrimaryStats(buff.Stats) || (HasSecondaryStats(buff.Stats) && !HasUnwantedStats(buff.Stats));
 
-        protected RotationSettings getRotationFromCalculationOptions(Stats stats, CalculationOptionsTree calcOpts, CharacterCalculationsTree calculatedStats) {
-            RotationSettings settings = new RotationSettings();
-            SpellProfile profile = calcOpts.Current;
+			return relevant;
+		}
 
-            switch (profile.LifebloomStackType)
-            {
-                case 0:
-                    settings.lifeBloomType = LifeBloomType.Slow;
-                    break;
-                case 1:
-                    settings.lifeBloomType = LifeBloomType.Fast;
-                    break;
-                case 2:
-                default:
-                    settings.lifeBloomType = LifeBloomType.Rolling;
-                    break;
-                case 3:
-                    settings.lifeBloomType = LifeBloomType.Slow2;
-                    break;
-                case 4:
-                    settings.lifeBloomType = LifeBloomType.Fast2;
-                    break;
-            }
+		public override bool IsEnchantRelevant(Enchant enchant, Character character)
+		{
+			// First we let the normal rules (profession, class, relevant stats) decide
+			bool relevant = base.IsEnchantRelevant(enchant, character);
 
-            settings.averageLifebloomStacks = (float)profile.LifebloomStackAmount;
-            settings.averageRejuv = (float)profile.RejuvAmount;
-            settings.averageRegrowth = (float)profile.RegrowthAmount;
+			// Next we use our special stat relevancy filtering.
+			if (relevant)
+				relevant = HasPrimaryStats(enchant.Stats) || (HasSecondaryStats(enchant.Stats) && !HasUnwantedStats(enchant.Stats));
 
-            settings.SwiftmendPerMin = profile.SwiftmendPerMinute;
-            settings.WildGrowthPerMin = profile.WildGrowthPerMinute;
+			return relevant;
+		}
 
-            settings.RejuvFraction = (float)profile.RejuvFrac / 100.0f;
-            settings.LifebloomFraction = (float)profile.LifebloomFrac / 100.0f;
-            settings.RegrowthFraction = (float)profile.RegrowthFrac / 100.0f;
-            settings.NourishFraction = (float)profile.NourishFrac / 100.0f;
 
-            settings.nourish1 = (float)profile.Nourish1 / 100f;
-            //settings.nourish2 = (float)profile.Nourish2 / 100f;
-            //settings.nourish3 = (float)profile.Nourish3 / 100f;
-            //settings.nourish4 = (float)profile.Nourish4 / 100f;
-            settings.nourish0 = 1.0f - (settings.nourish1); // + settings.nourish2 + settings.nourish3 + settings.nourish4);
+		public override Stats GetRelevantStats(Stats stats)
+		{
+			Stats s = new Stats()
+			{
+				// -- State Properties --
+				// Base Stats
+				Health = stats.Health,
+				Mana = stats.Mana,
+				Agility = stats.Agility,
+				Stamina = stats.Stamina,
+				Intellect = stats.Intellect,
+				Spirit = stats.Spirit,
+				Armor = stats.Armor,
+				HasteRating = stats.HasteRating,
+				CritRating = stats.CritRating,
+				SpellPower = stats.SpellPower,
+				MasteryRating = stats.MasteryRating,
+				// SpellPenetration = stats.SpellPenetration,
+				Mp5 = stats.Mp5,
+				BonusArmor = stats.BonusArmor,
 
-            settings.healTarget = HealTargetTypes.RaidHealing;
+				// Buffs / Debuffs
+				ManaRestoreFromMaxManaPerSecond = stats.ManaRestoreFromMaxManaPerSecond,
 
-            settings.livingSeedEfficiency = (float)profile.LivingSeedEfficiency / 100f;
+				// Combat Values
+				SpellCrit = stats.SpellCrit,
+				SpellCritOnTarget = stats.SpellCritOnTarget,
+				SpellHit = stats.SpellHit,
+				SpellCombatManaRegeneration = stats.SpellCombatManaRegeneration,
+				TargetArmorReduction = stats.TargetArmorReduction,
 
-            return settings;
-        }
+				// Spell Combat Ratings
+				SpellArcaneDamageRating = stats.SpellArcaneDamageRating,
+				SpellNatureDamageRating = stats.SpellNatureDamageRating,
 
-        protected void CalculateTriggers(CombatFactors cf, Dictionary<Trigger, float> triggerIntervals, Dictionary<Trigger, float> triggerChances)
-        {
-            float CastInterval = 1f / cf.CastsPerSecond;
-            float HealInterval = 1f / cf.HealsPerSecond;
-            float CritsRatio = cf.CritsPerSecond / cf.CastsPerSecond;
-            float RejuvInterval = 1f / cf.RejuvTicksPerSecond;
-            
-            triggerIntervals[Trigger.Use] = 0f;
-            triggerChances[Trigger.Use] = 1f;
+				// Equipment Effects
+				ManaRestore = stats.ManaRestore,
+				SpellsManaCostReduction = stats.SpellsManaCostReduction,
+				NatureSpellsManaCostReduction = stats.NatureSpellsManaCostReduction,
 
-            triggerIntervals[Trigger.SpellCast] = CastInterval;
-            triggerChances[Trigger.SpellCast] = 1f;
+				// -- MultiplicativeStats --
+				// Buffs / Debuffs
+				BonusHealthMultiplier = stats.BonusHealthMultiplier,
+				BonusManaMultiplier = stats.BonusManaMultiplier,
+				BonusStaminaMultiplier = stats.BonusStaminaMultiplier,
+				BonusIntellectMultiplier = stats.BonusIntellectMultiplier,
+				BonusSpiritMultiplier = stats.BonusSpiritMultiplier,
+				BaseArmorMultiplier = stats.BaseArmorMultiplier,
+				BonusArmorMultiplier = stats.BonusArmorMultiplier,
+				SpellHaste = stats.SpellHaste,
+				BonusSpellPowerMultiplier = stats.BonusSpellPowerMultiplier,
+				BonusHealingDoneMultiplier = stats.BonusHealingDoneMultiplier,
+				BonusCritHealMultiplier = stats.BonusCritHealMultiplier,
 
-            triggerIntervals[Trigger.HealingSpellCast] = CastInterval;
-            triggerChances[Trigger.HealingSpellCast] = 1f;
+				// -- NoStackStats
+				MovementSpeed = stats.MovementSpeed,
+				SnareRootDurReduc = stats.SnareRootDurReduc,
+				FearDurReduc = stats.FearDurReduc,
+				StunDurReduc = stats.StunDurReduc,
+				BonusManaPotionEffectMultiplier = stats.BonusManaPotionEffectMultiplier,
+				HighestStat = stats.HighestStat,
+			};
 
-            triggerIntervals[Trigger.HealingSpellHit] = HealInterval;
-            triggerChances[Trigger.HealingSpellHit] = 1f;
+			foreach (SpecialEffect effect in stats.SpecialEffects())
+			{
+				if (RelevantTriggers.Contains(effect.Trigger) && HasRelevantStats(effect.Stats))
+					s.AddSpecialEffect(effect);
+			}
+			return s;
+		}
 
-            triggerIntervals[Trigger.SpellCrit] = CastInterval;
-            triggerChances[Trigger.SpellCrit] = CritsRatio;
+		public override bool HasRelevantStats(Stats stats)
+		{
+			// These 3 calls should amount to the same list of stats as used in GetRelevantStats()
+			// Add a null call to catch relevance for set bonuses that have no actual stats
+			return string.IsNullOrEmpty(stats.ToString()) || HasPrimaryStats(stats) || HasSecondaryStats(stats) || HasExtraStats(stats);
+		}
 
-            triggerIntervals[Trigger.HealingSpellCrit] = CastInterval;
-            triggerChances[Trigger.HealingSpellCrit] = CritsRatio;
+		/// <summary>
+		/// HasPrimaryStats() should return true if the Stats object has any stats that define the item
+		/// as being 'for your class/spec'. For melee classes this is typical melee stats like Strength, 
+		/// Agility, AP, Expertise... For casters it would be spellpower, intellect, ...
+		/// As soon as an item/enchant/buff has any of the stats listed here, it will be assumed to be 
+		/// relevant unless explicitely filtered out.
+		/// Stats that could be usefull for both casters and melee such as HitRating, CritRating and Haste
+		/// don't belong here, but are SecondaryStats. Specific melee versions of these do belong here 
+		/// for melee, spell versions would fit here for casters.
+		/// </summary>
+		public bool HasPrimaryStats(Stats stats)
+		{
+			bool PrimaryStats =
+				// -- State Properties --
+				// Base Stats
+			    stats.Intellect != 0 ||
+			    stats.Spirit != 0 ||
+			    stats.SpellPower != 0 ||
+				// stats.SpellPenetration != 0 ||
 
-            triggerIntervals[Trigger.RejuvenationTick] = RejuvInterval;
-            triggerChances[Trigger.RejuvenationTick] = 1f;
-        }
+			    // Combat Values
+			    stats.SpellHaste != 0 ||
+			    stats.SpellCrit != 0 ||
+			    stats.SpellCritOnTarget != 0 ||
 
-        public enum ProcCalc
-        {
-            None,
-            Average,
-            Max
-        };
+			    stats.Mp5 != 0 ||
+			    stats.ManaRestoreFromMaxManaPerSecond != 0 ||
+			    stats.SpellCombatManaRegeneration != 0 ||
+			    stats.ManaRestore != 0 ||
+			    stats.SpellsManaCostReduction != 0 ||
+			    stats.NatureSpellsManaCostReduction != 0 ||
 
-        private void DoSpecialEffects(Character character, Stats stats, CombatFactors cf, float TotalTime, List<float> hasteRatings, List<float> hasteRatingUptimes, ProcCalc pc)
-        {
-            #region Initialize Triggers
-            Dictionary<Trigger, float> triggerIntervals = new Dictionary<Trigger, float>(); ;
-            Dictionary<Trigger, float> triggerChances = new Dictionary<Trigger, float>(); ;
-            CalculateTriggers(cf, triggerIntervals, triggerChances);
-            #endregion
+			    // Spell Combat Ratings
 
-            #region Haste Lists (seperately handled)
-            List<SpecialEffect> tempHasteEffects = new List<SpecialEffect>();
-            List<float> tempHasteEffectIntervals = new List<float>();
-            List<float> tempHasteEffectChances = new List<float>();
-            List<float> tempHasteEffectOffsets = new List<float>();
-            List<float> tempHasteEffectScales = new List<float>();
-            #endregion
+			    // -- MultiplicativeStats --
+				// Buffs / Debuffs
+			    stats.BonusIntellectMultiplier != 0 ||
+			    stats.BonusSpiritMultiplier != 0 ||
+			    stats.BonusCritHealMultiplier != 0 ||
+			    stats.BonusSpellPowerMultiplier != 0 ||
+			    stats.BonusHealingDoneMultiplier != 0 ||
+			    stats.BonusManaPotionEffectMultiplier != 0 ||
+			    stats.BonusPeriodicHealingMultiplier != 0
+			    ;
 
-            float offset = 0;
+			if (!PrimaryStats)
+			{
+				foreach (SpecialEffect effect in stats.SpecialEffects())
+				{
+					if (RelevantTriggers.Contains(effect.Trigger) && HasPrimaryStats(effect.Stats))
+					{
+						PrimaryStats = true;
+						break;
+					}
+				}
+			}
 
-            List<SpecialEffect> effects = new List<SpecialEffect>();
-            foreach (SpecialEffect effect in stats.SpecialEffects())
-            {
-                effect.Stats.GenerateSparseData();
+			return PrimaryStats;
+		}
 
-                #region Filter out unhandled effects
-                if (!triggerIntervals.ContainsKey(effect.Trigger)) continue;
-                #endregion
+		/// <summary>
+		/// HasSecondaryStats() should return true if the Stats object has any stats that are relevant for the 
+		/// model but only to a smaller degree, so small that you wouldn't typically consider the item.
+		/// Stats that are usefull to both melee and casters (HitRating, CritRating & Haste) fit in here also.
+		/// An item/enchant/buff having these stats would be considered only if it doesn't have any of the 
+		/// unwanted stats.  Group/Party buffs are slighly different, they would be considered regardless if 
+		/// they have unwanted stats.
+		/// Note that a stat may be listed here since it impacts the model, but may also be listed as an unwanted stat.
+		/// </summary>
+		public bool HasSecondaryStats(Stats stats)
+		{
+			bool SecondaryStats =
+				// -- State Properties --
+				// Base Stats
+			    stats.Mana != 0 ||
+			    stats.HasteRating != 0 ||
+			    stats.CritRating != 0 ||
+			    stats.MasteryRating != 0 ||
 
-                #region Filter out Haste effects
-                if (effect.Stats.HasteRating > 0)
-                {
-                    tempHasteEffects.Add(effect);
-                    // PATCH for use effects
-                    if (effect.Trigger == Trigger.Use)
-                    {
-                        tempHasteEffectIntervals.Add(effect.Cooldown);
-                        tempHasteEffectChances.Add(1f);
-                        tempHasteEffectOffsets.Add(offset);
-                        offset += effect.Duration;
-                    }
-                    else
-                    {
-                        tempHasteEffectIntervals.Add(triggerIntervals[effect.Trigger]);
-                        tempHasteEffectChances.Add(triggerChances[effect.Trigger]);
-                        tempHasteEffectOffsets.Add(0f);
-                    }
-                    tempHasteEffectScales.Add(1f);
-                    continue;
-                }
-                #endregion
+			    // -- MultiplicativeStats --
+				// Buffs / Debuffs
+			    stats.BonusManaMultiplier != 0 ||
 
-                effects.Add(effect);
-            }
+			    // -- NoStackStats
+			    stats.MovementSpeed != 0 ||
+			    stats.SnareRootDurReduc != 0 ||
+			    stats.FearDurReduc != 0 ||
+			    stats.StunDurReduc != 0 ||
+			    stats.HighestStat != 0;
 
-            #region Calculate Haste Breakdown
-            if (tempHasteEffects.Count == 0 || pc == ProcCalc.None)
-            {
-                hasteRatings.Add(0.0f);
-                hasteRatingUptimes.Add(1.0f);
-            }
-            else if (pc == ProcCalc.Max)
-            {
-                float hasteRating = 0;
-                for (int i = 0; i < tempHasteEffects.Count; i++) hasteRating += tempHasteEffects[i].Stats.HasteRating;
-                hasteRatings.Add(hasteRating);
-                hasteRatingUptimes.Add(1f);
-            }
-            else if (tempHasteEffects.Count == 1)
-            {   //Only one, add it to
-                SpecialEffect effect = tempHasteEffects[0];
-                float uptime = effect.GetAverageStackSize(tempHasteEffectIntervals[0], tempHasteEffectChances[0], 0, TotalTime);
-                hasteRatings.Add(effect.Stats.HasteRating);
-                hasteRatingUptimes.Add(uptime);
-                hasteRatings.Add(0.0f);
-                hasteRatingUptimes.Add(1.0f - uptime);
-            }
-            else if (tempHasteEffects.Count > 1)
-            {
-                WeightedStat[] HasteRatingWeights = SpecialEffect.GetAverageCombinedUptimeCombinations(tempHasteEffects.ToArray(), tempHasteEffectIntervals.ToArray(), tempHasteEffectChances.ToArray(), tempHasteEffectOffsets.ToArray(), tempHasteEffectScales.ToArray(), 0, TotalTime, AdditiveStat.HasteRating);
-                for (int i = 0; i < HasteRatingWeights.Length; i++)
-                {
-                    hasteRatings.Add(HasteRatingWeights[i].Value);
-                    hasteRatingUptimes.Add(HasteRatingWeights[i].Chance);
-                }
-            }
-            #endregion
+			if (!SecondaryStats)
+			{
+				foreach (SpecialEffect effect in stats.SpecialEffects())
+				{
+					if (RelevantTriggers.Contains(effect.Trigger) && HasSecondaryStats(effect.Stats))
+					{
+						SecondaryStats = true;
+						break;
+					}
+				}
+			}
 
-            /*
-            #region Calculate average Haste from effects (capped)
-            if (tempHasteRatings.Count > 0f)
-            {
-                float cap = (1.5f / (1f + stats.SpellHaste) - 1) * StatConversion.RATING_PER_SPELLHASTE - stats.HasteRating;
+			return SecondaryStats;
+		}
 
-                float HasteRatingFromProcs = 0f;
-                for (int i = 0; i < tempHasteRatings.Count; i++)
-                {
-                    float Haste = Math.Min(cap, tempHasteRatings[i]);
-                    HasteRatingFromProcs += tempHasteRatingUptimes[i] * Haste;
-                }
+		/// <summary>
+		/// Return true if the Stats object has any stats that don't influence the model but that you do want 
+		/// to display in tooltips and in calculated summary values.
+		/// </summary>
+		public bool HasExtraStats(Stats stats)
+		{
+			bool ExtraStats =
+			    stats.Health != 0 ||
+			    stats.Stamina != 0 ||
+			    stats.Armor != 0 ||
+			    stats.BonusArmor != 0 ||
+			    stats.BonusHealthMultiplier != 0 ||
+			    stats.BonusStaminaMultiplier != 0 ||
+			    stats.BaseArmorMultiplier != 0 ||
+			    stats.BonusArmorMultiplier != 0;
 
-                stats.HasteRating += HasteRatingFromProcs;                
-            }
-            #endregion
-            */
+			if (!ExtraStats)
+			{
+				foreach (SpecialEffect effect in stats.SpecialEffects())
+				{
+					if (RelevantTriggers.Contains(effect.Trigger) && HasExtraStats(effect.Stats))
+					{
+						ExtraStats = true;
+						break;
+					}
+				}
+			}
 
-            AccumulateSpecialEffects(character, ref stats, TotalTime, triggerIntervals, triggerChances, effects, 1f, pc);
+			return ExtraStats;
+		}
 
-            #region Clear special effects from Stats
-            for (int i = 0; i < stats._rawSpecialEffectDataSize; i++) stats._rawSpecialEffectData[i] = null;
-            stats._rawSpecialEffectDataSize = 0;
-            #endregion
-        }
+		/// <summary>
+		/// Return true if the Stats object contains any stats that are making the item undesired.
+		/// Any item having only Secondary stats would be removed if it also has one of these.
+		/// </summary>
+		public bool HasUnwantedStats(Stats stats)
+		{
+			/// List of stats that will filter out some buffs (Flasks, Elixirs & Scrolls), Enchants and Items.
+			bool UnwantedStats =
+			    stats.Strength > 0 ||
+			    stats.Agility > 0 ||
+			    stats.AttackPower > 0 ||
+			    stats.ExpertiseRating > 0 ||
+			    stats.DodgeRating > 0 ||
+			    stats.ParryRating > 0 ||
+			    stats.BlockRating > 0 ||
+			    stats.Resilience > 0;
 
-        protected void AccumulateSpecialEffects(Character character, ref Stats stats, float FightDuration, Dictionary<Trigger, float> triggerIntervals, Dictionary<Trigger, float> triggerChances, List<SpecialEffect> effects, float weight, ProcCalc pc) 
-        {
-            foreach (SpecialEffect effect in effects) 
-            {
-                Stats effectStats = effect.Stats;
+			if (!UnwantedStats)
+			{
+				foreach (SpecialEffect effect in stats.SpecialEffects())
+				{
+					if (/*RelevantTriggers.Contains(effect.Trigger) && */HasUnwantedStats(effect.Stats))    // An unwanted stat could be behind a trigger we don't model.
+					{
+						UnwantedStats = true;
+						break;
+					}
+				}
+			}
 
-                float upTime = 0f;
+			return UnwantedStats;
+		}
 
-                #region Filter out Haste effects
-                if (effect.Stats.HasteRating > 0f) continue;
-                #endregion
+		public Stats GetBuffsStats(Character character, CalculationOptionsTree calcOpts)
+		{
+			List<Buff> removedBuffs = new List<Buff>();
+			List<Buff> addedBuffs = new List<Buff>();
 
-                if (effect.Trigger == Trigger.Use)
-                {
-                    if (effect.Stats._rawSpecialEffectDataSize >= 1)
-                    {
-                        upTime = effect.GetAverageUptime(0f, 1f, 0, FightDuration);
-                        List<SpecialEffect> nestedEffect = new List<SpecialEffect>(effect.Stats.SpecialEffects());
-                        Stats _stats2 = effectStats.Clone();
-                        AccumulateSpecialEffects(character, ref _stats2, effect.Duration, triggerIntervals, triggerChances, nestedEffect, upTime, pc);
-                        effectStats = _stats2;
-                    }
-                    else
-                    {
-                        upTime = effect.GetAverageStackSize(0f, 1f, 0, FightDuration);
-                    }
-                }
-                else if (effect.Duration == 0f)
-                {
-                    upTime = effect.GetAverageProcsPerSecond(triggerIntervals[effect.Trigger], triggerChances[effect.Trigger],
-                                                             0, FightDuration);
-                }
-                else if (triggerIntervals.ContainsKey(effect.Trigger))
-                {
-                    upTime = effect.GetAverageStackSize(triggerIntervals[effect.Trigger], triggerChances[effect.Trigger],
-                                                             0, FightDuration);
-                }
+			Stats statsBuffs = GetBuffsStats(character.ActiveBuffs, character.SetBonusCount);
 
-                if (upTime > 0f)
-                {
-                    if (pc == ProcCalc.None && upTime < 0.5f)
-                    {
-                        Stats s = new Stats()
-                        {
-                            SpellPower = effectStats.SpellPower,
-                            CritRating = effectStats.CritRating,
-                            //HasteRating = effectStats.HasteRating,
-                            SpellHaste = effectStats.SpellHaste
-                        };
-                        effectStats.SpellPower = 0;
-                        effectStats.CritRating = 0;
-                        //effectStats.HasteRating = 0;
-                        effectStats.SpellHaste = 0;
-                        stats.Accumulate(effectStats, upTime * weight);
-                        effectStats.SpellPower = s.SpellPower;
-                        effectStats.CritRating = s.CritRating;
-                        //effectStats.HasteRating = s.HasteRating;
-                        effectStats.SpellHaste = s.SpellHaste;
-                    }
-                    else if (pc == ProcCalc.Max && upTime < 0.5f)
-                    {
-                        Stats s = new Stats()
-                        {
-                            SpellPower = effectStats.SpellPower,
-                            CritRating = effectStats.CritRating,
-                            //HasteRating = effectStats.HasteRating,
-                            SpellHaste = effectStats.SpellHaste
-                        };
-                        effectStats.SpellPower = 0;
-                        effectStats.CritRating = 0;
-                        //effectStats.HasteRating = 0;
-                        effectStats.SpellHaste = 0;
-                        stats.Accumulate(effectStats, upTime * weight);
-                        effectStats.SpellPower = s.SpellPower;
-                        effectStats.CritRating = s.CritRating;
-                        //effectStats.HasteRating = s.HasteRating;
-                        effectStats.SpellHaste = s.SpellHaste;
-                        stats.Accumulate(s, weight);
-                    }
-                    else
-                    {
-                        stats.Accumulate(effectStats, upTime * weight);
-                    }
-                }
-            }
-        }
+			foreach (Buff b in removedBuffs)
+			{
+				character.ActiveBuffsAdd(b);
+			}
+			foreach (Buff b in addedBuffs)
+			{
+				character.ActiveBuffs.Remove(b);
+			}
 
-        public override CharacterCalculationsBase GetCharacterCalculations(Character character, Item additionalItem, bool referenceCalculation, bool significantChange, bool needsDisplayCalculations)
-        {
-            // First things first, we need to ensure that we aren't using bad data
-            CharacterCalculationsTree calc = new CharacterCalculationsTree();
-            if (character == null) { return calc; }
-            CalculationOptionsTree calcOpts = character.CalculationOptions as CalculationOptionsTree;
-            if (calcOpts == null) { return calc; }
-            //
-            SpellProfile profile = calcOpts.Current;
-            boss = character.BossOptions;
-            calc.boss = character.BossOptions;
+			return statsBuffs;
+		}
 
-            calc.LocalCharacter = character;
-            calc.BasicStats = GetCharacterStats(character, additionalItem); //Move spell power and mastery inside.
+		public override void SetDefaults(Character character)
+		{
+			character.ActiveBuffsAdd(("Arcane Tactics"));
+			character.ActiveBuffsAdd(("Arcane Brilliance (Mana)"));
+			character.ActiveBuffsAdd(("Arcane Brilliance (SP%)"));
+			character.ActiveBuffsAdd(("Blessing of Might (Mp5)"));
+			character.ActiveBuffsAdd(("Tree Form"));
+			character.ActiveBuffsAdd(("Elemental Oath"));
+			character.ActiveBuffsAdd(("Replenishment"));
+			character.ActiveBuffsAdd(("Power Word: Fortitude"));
+			character.ActiveBuffsAdd(("Mark of the Wild"));
+			character.ActiveBuffsAdd(("Heroism/Bloodlust"));
+			character.ActiveBuffsAdd(("Power Infusion"));
+			character.ActiveBuffsAdd(("Flask of the Draconic Mind"));
+			character.ActiveBuffsAdd(("Intellect Food"));
+		}
+		#endregion
 
-            // All spells: Damage +(1 * Int)
-            float spellDamageFromIntPercent = 1f;
-            // Fix for rounding error in converting partial points of int/spirit to spell power
-            float spellPowerFromStats = (float)Math.Floor(spellDamageFromIntPercent * (Math.Max(0f, calc.BasicStats.Intellect - 10)));
-            calc.SpellPower = calc.BasicStats.SpellPower + spellPowerFromStats;
+		private static SpecialEffect[] naturesGrace = null;
+		public static SpecialEffect[] NaturesGrace
+		{
+			get
+			{
+				if (naturesGrace == null)
+				{
+					naturesGrace = new SpecialEffect[4];
+					for (int i = 1; i <= 3; ++i)
+						naturesGrace[i] = new SpecialEffect(Trigger.Use, new Stats() { SpellHaste = 0.05f * i }, 15.0f, 60.0f, 1f);
+				}
+				return naturesGrace;
+			}
+		}
 
-            //// Mastery from rating
-            //calc.Mastery = 8.0f + StatConversion.GetMasteryFromRating(calc.BasicStats.MasteryRating);
+		public class TreeOfLifeStats : Stats
+		{
+			public override string ToString() { return "Tree of Life"; }
+		}
 
-            #region Rotations
-            Stats stats = calc.BasicStats;
-            stats.ManaRestore /= boss.BerserkTimer; //  profile.FightDuration;
-            //float replenish = stats.ManaRestoreFromMaxManaPerSecond >= 0.002f ? 0.002f : 0;
-            //stats.ManaRestore += (stats.ManaRestoreFromMaxManaPerSecond - replenish) * stats.Mana;
-            //stats.ManaRestoreFromMaxManaPerSecond = replenish;
-            
-            float ExtraHealing = 0f;
-            RotationSettings settings = getRotationFromCalculationOptions(stats, calcOpts, calc);
+		private static SpecialEffect[] treeOfLife = null;
+		public static SpecialEffect[] TreeOfLife
+		{
+			get
+			{
+				if (treeOfLife == null)
+				{
+					treeOfLife = new SpecialEffect[3];
+					for (int i = 1; i <= 2; ++i)
+						treeOfLife[i] = new SpecialEffect(Trigger.Use, new TreeOfLifeStats(), 25 + 3 * i, 180.0f);
+				}
+				return treeOfLife;
+			}
+		}
 
-            // Initial run
-            SustainedResult rot = Solver.SimulateHealing(calc, stats, calcOpts, boss, settings);
+		public override Stats GetCharacterStats(Character character, Item additionalItem)
+		{
+			CalculationOptionsTree calcOpts = character.CalculationOptions as CalculationOptionsTree;
+			if (calcOpts == null)
+				calcOpts = new CalculationOptionsTree();
 
-            List<float> hasteRatings = new List<float>();
-            List<float> hasteRatingUptimes = new List<float>();
+			Stats stats = new Stats();
+			Stats statsBase = BaseStats.GetBaseStats(character.Level, character.Class, character.Race);
+			stats.Accumulate(statsBase);
 
-            ProcCalc pc = ProcCalc.None;
-            switch (calcOpts.ProcType)
-            {
-                case 0:
-                    pc = ProcCalc.None;
-                    break;
-                case 1:
-                    pc = ProcCalc.Average;
-                    break;
-                case 2:
-                    pc = ProcCalc.Max;
-                    break;
-            }
+			// Get the gear/enchants/buffs stats loaded in
+			stats.Accumulate(GetItemStats(character, additionalItem));
+			stats.Accumulate(GetBuffsStats(character, calcOpts));
 
-            CombatFactors cfs = rot.getCombatFactors();
-            cfs.Compute();
+			#region Set Bonuses
+			int T11Count;
+			character.SetBonusCount.TryGetValue("Stormrider's Vestments", out T11Count);
+			if (T11Count >= 4)
+				stats.Spirit += 540;
+			#endregion
 
-            for (int k = 0; k < 2; k++) {
-                // Create new stats instance with procs
-                stats = GetCharacterStats(character, additionalItem);
-                stats.ManaRestore /= boss.BerserkTimer;  // profile.FightDuration;
+			// Talented bonus multipliers
+			Stats statsTalents = new Stats()
+			{
+				BonusIntellectMultiplier = (1 + 0.02f * character.DruidTalents.HeartOfTheWild) * (Character.ValidateArmorSpecialization(character, ItemType.Leather) ? 1.05f : 1f) - 1f,
+				BonusManaMultiplier = 0.05f * character.DruidTalents.Furor,
+			};
 
-                hasteRatings.Clear();
-                hasteRatingUptimes.Clear();
-                DoSpecialEffects(character, stats, cfs, rot.TotalTime, hasteRatings, hasteRatingUptimes, pc);
+			stats.Accumulate(statsTalents);
 
-                //// Add replenish
-                //replenish = stats.ManaRestoreFromMaxManaPerSecond >= 0.002f ? 0.002f : 0;
-                //stats.ManaRestore += (stats.ManaRestoreFromMaxManaPerSecond - replenish) * stats.Mana;
-                //stats.ManaRestoreFromMaxManaPerSecond = replenish;
+			/* we now use custom handling for this
+			if (character.DruidTalents.NaturesGrace > 0)
+				stats.AddSpecialEffect(NaturesGrace[character.DruidTalents.NaturesGrace]);
+			 */
 
-                ExtraHealing = stats.Healed;
+			// Base stats: Intellect, Stamina, Spirit
+			stats.Stamina = (float)Math.Floor(stats.Stamina * (1 + stats.BonusStaminaMultiplier));
+			stats.Intellect = stats.Intellect * (1 + stats.BonusIntellectMultiplier);
+			stats.Agility = stats.Agility * (1 + stats.BonusAgilityMultiplier);
+			stats.Spirit = (float)Math.Floor(stats.Spirit * (1 + stats.BonusSpiritMultiplier));
 
-                if (false)//calcOpts.IgnoreAllHasteEffects)
-                {
-                    /*stats.SpellHaste = calculationResult.BasicStats.SpellHaste;
-                    stats.HasteRating = calculationResult.BasicStats.HasteRating;
+			// Derived stats: Health, mana pool, armor
+			stats.Health = (float)Math.Round(stats.Health + StatConversion.GetHealthFromStamina(stats.Stamina));
+			stats.Health = (float)Math.Floor(stats.Health * (1f + stats.BonusHealthMultiplier));
+			stats.Mana = (float)Math.Round(stats.Mana + StatConversion.GetManaFromIntellect(stats.Intellect));
+			stats.Mana = (float)Math.Floor(stats.Mana * (1f + stats.BonusManaMultiplier));
 
-                    rot = Solver.SimulateHealing(calculationResult, stats, calcOpts, settings);
-                    cfs = rot.getCombatFactors();
-                    cfs.Compute();*/
-                }
-                else
-                {
-                    cfs = new CombatFactors();
-                    float AverageHasteRating = 0;
-                    for (int i = 0; i < hasteRatings.Count; i++)
-                    {
-                        stats.HasteRating += hasteRatings[i];
-                        SustainedResult r = Solver.SimulateHealing(calc, stats, calcOpts, boss, settings);
-                        cfs.Accumulate(r.getCombatFactors(), hasteRatingUptimes[i]);
-                        stats.HasteRating -= hasteRatings[i];
-                        AverageHasteRating += hasteRatings[i] * hasteRatingUptimes[i];
-                        if (i == 0) rot = r;
-                    }
-                    cfs.Compute();
-                    stats.HasteRating += AverageHasteRating; // For Burst
-                }
-            }
-            calc.Sustained = rot;
-            calc.CombatStats = stats;
-            #endregion
+			// Armor
+			stats.Armor = stats.Armor * (1f + stats.BaseArmorMultiplier);
+			stats.BonusArmor = stats.BonusArmor * (1f + stats.BonusArmorMultiplier);
+			stats.Armor += stats.BonusArmor;
+			stats.Armor = (float)Math.Round(stats.Armor);
 
-            calc.SingleTarget = Solver.CalculateSingleTargetBurst(calc, stats, calcOpts, Solver.SingleTargetIndexToRotation(calcOpts.SingleTargetRotation));
+			// Crit rating
+			// Application order: Stats, Talents, Gear
+			// All spells: Crit% + (0.02 * Nature's Majesty)
+			stats.SpellCrit += 0.02f * character.DruidTalents.NaturesMajesty;
 
-            calc.SingleTargetHPS = calc.SingleTarget[0].HPS;
-            calc.SustainedHPS = cfs.TotalHealing / rot.TotalTime + ExtraHealing;
+			if (character.DruidTalents.NaturesGrace > 0)
+				stats.AddSpecialEffect(NaturesGrace[character.DruidTalents.NaturesGrace]);
 
-            #region Survival Points
-            float DamageReduction = StatConversion.GetArmorDamageReduction(character.BossOptions.Level, stats.Armor, 0, 0/*, 0*/);
-            calc.SurvivalPoints = stats.Health / (1f - DamageReduction) / 100f * calcOpts.SurvValuePer100;
-            #endregion
+			if (character.DruidTalents.TreeOfLife > 0)
+				stats.AddSpecialEffect(TreeOfLife[character.DruidTalents.NaturalShapeshifter]);
 
-            // Apply diminishing returns - this needs to be removed with testing.
+			return stats;
+		}
 
-            calc.SingleTargetPoints = DiminishingReturns.CapWithMaximum2(calc.SingleTargetHPS, calcOpts.SingleTarget);
-            calc.SustainedPoints = DiminishingReturns.CapWithMaximum2(calc.SustainedHPS, calcOpts.SustainedTarget);
+		public override CharacterCalculationsBase GetCharacterCalculations(Character character, Item additionalItem, bool referenceCalculation, bool significantChange, bool needsDisplayCalculations)
+		{
+			// First things first, we need to ensure that we aren't using bad data
+			CharacterCalculationsTree calc = new CharacterCalculationsTree();
+			if (character == null)
+				return calc;
+			calc.BasicStats = (Stats)GetCharacterStats(character, additionalItem);
+			new TreeSolver(character, calc);
+			return calc;
+		}
 
-            // --- Replacement code from here
-            Rotation rotionNew = new Rotation(104, character, calc.CombatStats, boss);
-            calc.SustainedPoints = rotionNew.HPS;
+		#region Custom Charts
 
-            calc.OverallPoints = calc.SingleTargetPoints + calc.SustainedPoints + calc.SurvivalPoints;
+		private string[] customChartNames = new string[] { 
+			"Haste Breakpoints (vs Mastery)",
+			"Haste Breakpoints (vs Spirit)",
+			"Haste Breakpoints (vs Crit)",
+			"Haste Breakpoints (vs Intellect)"
+		};
 
-            return calc;
-        }
-        private static readonly SpecialEffect[] _SE_NaturesGrace = new SpecialEffect[] {
-            null,
-            new SpecialEffect(Trigger.HealingSpellCrit, new Stats() { SpellHaste = 0.2f }, 3f, 0, 1 * 1f / 3f, 1),
-            new SpecialEffect(Trigger.HealingSpellCrit, new Stats() { SpellHaste = 0.2f }, 3f, 0, 2 * 1f / 3f, 1),
-            new SpecialEffect(Trigger.HealingSpellCrit, new Stats() { SpellHaste = 0.2f }, 3f, 0, 3 * 1f / 3f, 1),
-        };
-        public override Stats GetCharacterStats(Character character, Item additionalItem) { return GetCharacterStats(character, additionalItem, new Stats()); }
-        public Stats GetCharacterStats(Character character, Item additionalItem, Stats statsProcs) {
-            CalculationOptionsTree calcOpts = character.CalculationOptions as CalculationOptionsTree;
-            DruidTalents talents = character.DruidTalents;
-            SpellProfile profile = calcOpts.Current;
+		public override string[] CustomChartNames
+		{
+			get
+			{
+				return customChartNames;
+			}
+		}
 
-            Stats statsRace = BaseStats.GetBaseStats(character.Level, character.Class, character.Race); //GetRacialBaseStats(character.Race);
-            TreeConstants.BaseMana = statsRace.Mana; // Setup TreeConstant
+		public int[] GetHasteBreakpoints(Character character, int maxHaste)
+		{
+			Stats stats = GetCharacterStats(character, null);
 
-            Stats statsTalents = new Stats() {
-#if !RAWR4
-                BonusAgilityMultiplier   = (1f + 0.01f * talents.SurvivalOfTheFittest * 2f) * (1f + 0.01f * talents.ImprovedMarkOfTheWild) - 1f,
-                BonusIntellectMultiplier = (1f + 0.01f * talents.SurvivalOfTheFittest * 2f) * (1f + 0.01f * talents.ImprovedMarkOfTheWild) * (1f + 0.04f * talents.HeartOfTheWild) - 1f,
-                BonusSpiritMultiplier    = (1f + 0.01f * talents.SurvivalOfTheFittest * 2f) * (1f + 0.01f * talents.ImprovedMarkOfTheWild) * (1f + 0.05f * talents.LivingSpirit) - 1f,
-                BonusStaminaMultiplier   = (1f + 0.01f * talents.SurvivalOfTheFittest * 2f) * (1f + 0.01f * talents.ImprovedMarkOfTheWild) - 1f,
-                BonusStrengthMultiplier  = (1f + 0.01f * talents.SurvivalOfTheFittest * 2f) * (1f + 0.01f * talents.ImprovedMarkOfTheWild) - 1f,
-                BonusArmorMultiplier     = 0.80f * talents.ImprovedTreeOfLife,
-                SpellHaste               = ((1f + 0.01f * talents.CelestialFocus) * (1f + 0.02f * talents.GiftOfTheEarthmother)) - 1f,
+			List<int> hasteRatingProcsList = new List<int>();
+			List<float> spellHasteProcsList = new List<float>();
 
-                //SpellDamageFromSpiritPercentage = talents.ImprovedTreeOfLife * 0.05f,
-                SpellCombatManaRegeneration = talents.Intensity * 0.5f / 3f, //still necessary?
-#endif
-                BonusIntellectMultiplier = (0.02f * talents.HeartOfTheWild ) +
-                                           (Character.ValidateArmorSpecialization(character, ItemType.Leather) ? 0.05f: 0f),  
-                
-            };
+			foreach (SpecialEffect effect in stats.SpecialEffects())
+			{
+				if (CalculationsTree.RelevantTriggers.Contains(effect.Trigger))
+				{
+					if (effect.Stats.HasteRating > 0)
+						hasteRatingProcsList.Add((int)effect.Stats.HasteRating);
+					if (effect.Stats.SpellHaste > 0)
+						spellHasteProcsList.Add(1 + effect.Stats.SpellHaste);
+				}
+			}
 
-#if !RAWR4
-            if (!calcOpts.IgnoreNaturesGrace && talents.NaturesGrace > 0) { statsTalents.AddSpecialEffect(_SE_NaturesGrace[talents.NaturesGrace]); }
-#endif
+			int[] hasteRatingProcs = hasteRatingProcsList.ToArray();
+			float[] spellHasteProcs = spellHasteProcsList.ToArray();
 
-            Stats statsBaseGear = GetItemStats(character, additionalItem);
-            Stats statsBuffs = GetBuffsStats(character, calcOpts);
-            Stats statsTotal = statsBaseGear + statsBuffs + statsRace + statsTalents + statsProcs;
+			List<int> baseHasteBreakpointsList = new List<int>();
 
-            statsTotal.Agility   = (float)Math.Floor(statsTotal.Agility   * (1f + statsTotal.BonusAgilityMultiplier));
-            statsTotal.Stamina   = (float)Math.Floor(statsTotal.Stamina   * (1f + statsTotal.BonusStaminaMultiplier));
-            statsTotal.Intellect = (float)Math.Floor(statsTotal.Intellect * (1f + statsTotal.BonusIntellectMultiplier));
-            statsTotal.Spirit    = (float)Math.Floor(statsTotal.Spirit    * (1f + statsTotal.BonusSpiritMultiplier));
-            statsTotal.Armor     = (float)Math.Floor(statsTotal.Armor     * (1f + statsTotal.BonusArmorMultiplier));
+			string[] spells = { "LB", "WG", "Rj", "Tq" };
+			int[] tickRates = { 1, 1, 3, 2 };
+			int[] durations = { 10, 7, 12, 8 };
 
-            if (statsTotal.HighestStat > 0) {
-                if (statsTotal.Spirit > statsTotal.Intellect) {
-                    statsTotal.Spirit += (float)Math.Floor(statsTotal.HighestStat * (1f + statsTotal.BonusSpiritMultiplier));
-                } else {
-                    statsTotal.Intellect += (float)Math.Floor(statsTotal.HighestStat * (1f + statsTotal.BonusIntellectMultiplier));
-                }
-            }
+			int numHasteMults = 1 << spellHasteProcs.Length;
+			double[] hasteMults = new double[numHasteMults];
+			for (int i = 0; i < numHasteMults; ++i)
+			{
+				double hasteMult = 1 + stats.SpellHaste;
+				for (int j = 0; j < spellHasteProcs.Length; ++j)
+				{
+					if ((i & (1 << j)) != 0)
+						hasteMult *= spellHasteProcs[j];
+				}
 
-            // Add spellpower from spirit, intellect and... agility :)
-            statsTotal.SpellPower = (float)Math.Round(statsTotal.SpellPower
-                                                    //+ (statsTotal.SpellDamageFromSpiritPercentage * statsTotal.Spirit) // This line is no longer valid
-                                                    + (statsTotal.Intellect /* * talents.LunarGuidance * 0.04*/)  // Googling intellect to spellpower comes up at a 1:1 ratio, needs more testing
-                //                                                    + (talents.NurturingInstinct * 0.35f * statsTotal.Agility)  Technically true in patch 4.0, but not reachable from resto spec
-                                                    );
+				hasteMults[i] = hasteMult;
+			}
 
-            statsTotal.Mana = statsTotal.Mana + StatConversion.GetManaFromIntellect(statsTotal.Intellect);
-            statsTotal.Mana *= (1f + statsTotal.BonusManaMultiplier) * (1f + 0.05f*talents.Furor);
+			int numHasteOffsets = 1 << hasteRatingProcs.Length;
+			int[] hasteOffsets = new int[numHasteOffsets];
+			for (int i = 0; i < numHasteOffsets; ++i)
+			{
+				int hasteOffset = 0;
+				for (int j = 0; j < hasteRatingProcs.Length; ++j)
+				{
+					if ((i & (1 << j)) != 0)
+						hasteOffset += hasteRatingProcs[j];
+				}
 
-            statsTotal.Health = (float)Math.Round(statsTotal.Health + StatConversion.GetHealthFromStamina(statsTotal.Stamina));
-//            statsTotal.Mp5   += (float)Math.Floor(statsTotal.Intellect * (talents.Dreamstate > 0 ? talents.Dreamstate * 0.03f + 0.01f : 0f));
+				hasteOffsets[i] = hasteOffset;
+			}
 
-            statsTotal.SpellCrit = (float)Math.Round((StatConversion.GetSpellCritFromIntellect(statsTotal.Intellect)
-                                                    + StatConversion.GetSpellCritFromRating(statsTotal.CritRating)
-                                                    + (statsTotal.SpellCrit)
-                                                    + 0.02f * talents.NaturesMajesty), 4);          // Round to xx.xx %
-                                                    //+ 0.01f * talents.NaturalPerfection) * 100f, 2);
+			int[] ticks = new int[numHasteMults * 4];
+			int gotem = 0;
+			bool[] hasteBreakpointsMask = new bool[maxHaste + 1];
+			int maxh = maxHaste + hasteOffsets[hasteOffsets.Length - 1];
+			for (int h = 0; h <= maxh; ++h)
+			{
+				double hasteRatingMult = 1 + StatConversion.GetSpellHasteFromRating(h);
+				bool isBreakpoint = h == 0;
+				int curGotem = (int)Math.Floor(4.0f * (1 + StatConversion.GetSpellHasteFromRating((float)h)) + 0.5f);
+				if (curGotem > gotem)
+				{
+					isBreakpoint = true;
+					gotem = curGotem;
+				}
+				for (int i = 0; i < numHasteMults * 4; ++i)
+				{
+					double curTickRate = Math.Round(tickRates[i & 3] / (hasteMults[i >> 2] * hasteRatingMult), 3);
+					int curTicks = (int)Math.Ceiling(durations[i & 3] / curTickRate - 0.5);
+					if (curTicks > ticks[i])
+					{
+						ticks[i] = curTicks;
+						isBreakpoint = true;
+					}
+				}
+				if (isBreakpoint)
+				{
+					for (int j = 0; j < numHasteOffsets; ++j)
+					{
+						int hr = h - hasteOffsets[j];
+						if (hr >= 0 && hr <= maxHaste)
+							hasteBreakpointsMask[hr] = true;
+					}
+				}
+			}
 
-            //Mastery and Spell Power from INT
+			List<int> hasteBreakpointsList = new List<int>();
+			for (int h = 0; h <= maxHaste; ++h)
+			{
+				if (hasteBreakpointsMask[h])
+					hasteBreakpointsList.Add(h);
+			}
+			return hasteBreakpointsList.ToArray();
+		}
 
-            return statsTotal;
-        }
-        public override ComparisonCalculationBase[] GetCustomChartData(Character character, string chartName)
-        {
-            List<ComparisonCalculationBase> comparisonList = new List<ComparisonCalculationBase>();
 
-            CalculationOptionsTree calculationOptions = character.CalculationOptions as CalculationOptionsTree;
-            DruidTalents talents = character.DruidTalents;
-            CharacterCalculationsTree calculationResult = GetCharacterCalculations(character) as CharacterCalculationsTree;
+		public override ComparisonCalculationBase[] GetCustomChartData(Character character, string chartName)
+		{
+			int i = customChartNames.FindIndex(x => x == chartName);
+			if(i < 0)
+				return new ComparisonCalculationBase[0];
+			//if(i <= 4)
+			{
+				List<ComparisonCalculationBase> chart = new List<ComparisonCalculationBase>();
+				CharacterCalculationsTree calcsBase = GetCharacterCalculations(character) as CharacterCalculationsTree;
+				Character c2 = character.Clone();
 
-            int customRotationsMax = 105;
+				bool curIsBreakpoint = false;
+				int[] hasteBreakpoints = GetHasteBreakpoints(character, 5000);
+				foreach(int hb in hasteBreakpoints)
+				{
+					float hasteDelta = hb - calcsBase.BasicStats.HasteRating;
+					if (hasteDelta == 0)
+						curIsBreakpoint = true;
+					Buff buff = new Buff();
+					buff.Name = "Haste adjustment to meet breakpoint";
+					buff.Stats.HasteRating += hasteDelta;
+					bool stop = false;
+					switch(i)
+					{
+						case 0:
+							if (hasteDelta > calcsBase.BasicStats.MasteryRating)
+								stop = true;
+							buff.Stats.MasteryRating -= hasteDelta;
+							break;
+						case 1:
+							if (hasteDelta > calcsBase.BasicStats.Spirit)
+								stop = true;
+							buff.Stats.Spirit -= hasteDelta;
+							break;
+						case 2:
+							if (hasteDelta > calcsBase.BasicStats.CritRating)
+								stop = true;
+							buff.Stats.CritRating -= hasteDelta;
+							break;
+						case 3:
+							if (hasteDelta > calcsBase.BasicStats.Intellect)
+								stop = true;
+							buff.Stats.Intellect -= hasteDelta;
+							break;
+					}
+					if (stop)
+						break;
+					
+					c2.ActiveBuffs.Add(buff);
+					CharacterCalculationsTree calcsCur = GetCharacterCalculations(c2) as CharacterCalculationsTree;
+					c2.ActiveBuffs.Remove(buff);
 
-            switch (chartName)
-            {
-                #region Mana sources (sustained)
-                case "Mana sources (sustained)":
-                    _subPointNameColors = _subPointNameColorsMPS;
-                    ComparisonCalculationTree gear = new ComparisonCalculationTree()
-                    {
-                        Name = "MP5 from gear, buffs and MP5 procs",
-                        Equipped = false,
-                        OverallPoints = calculationResult.Sustained.GearMPS,
-                        SubPoints = new float[] { calculationResult.Sustained.GearMPS, 0, 0 }
-                    };
-                    comparisonList.Add(gear);
-                    ComparisonCalculationTree procs = new ComparisonCalculationTree()
-                    {
-                        Name = "Mana from procs",
-                        Equipped = false,
-                        OverallPoints = calculationResult.Sustained.ProcsMPS,
-                        SubPoints = new float[] { calculationResult.Sustained.ProcsMPS, 0, 0 }
-                    };
-                    comparisonList.Add(procs);
-                    ComparisonCalculationTree revitalize = new ComparisonCalculationTree()
-                    {
-                        Name = "Mana from Revitalize",
-                        Equipped = false,
-                        OverallPoints = calculationResult.Sustained.RevitalizeMPS,
-                        SubPoints = new float[] { calculationResult.Sustained.RevitalizeMPS, 0, 0 }
-                    };
-                    comparisonList.Add(revitalize);
-                    ComparisonCalculationTree spiritIC = new ComparisonCalculationTree()
-                    {
-                        Name = "Spirit",
-                        Equipped = false,
-                        OverallPoints = calculationResult.Sustained.SpiritMPS,
-                        SubPoints = new float[] { calculationResult.Sustained.SpiritMPS, 0, 0 }
-                    };
-                    comparisonList.Add(spiritIC);
-                    ComparisonCalculationTree replenishment = new ComparisonCalculationTree()
-                    {
-                        Name = "Replenishment",
-                        Equipped = false,
-                        OverallPoints = calculationResult.Sustained.ReplenishmentMPS,
-                        SubPoints = new float[] { calculationResult.Sustained.ReplenishmentMPS, 0, 0 }
-                    };
-                    comparisonList.Add(replenishment);
-                    ComparisonCalculationTree innervates = new ComparisonCalculationTree()
-                    {
-                        Name = "Innervates",
-                        Equipped = false,
-                        OverallPoints = calculationResult.Sustained.InnervateMPS,
-                        SubPoints = new float[] { calculationResult.Sustained.InnervateMPS, 0, 0 }
-                    };
-                    comparisonList.Add(innervates);
-                    
-                    return comparisonList.ToArray();
-                #endregion
-                #region Casting time percentage per spell (sustained)
-                case "Casting time percentage per spell (sustained)":
-                    {
-                        _subPointNameColors = _subPointNameColorsCF;
-                        ComparisonCalculationTree rejuv = new ComparisonCalculationTree()
-                        {
-                            Name = "Rejuvenation",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.RejuvCF_unreduced * 100,
-                            SubPoints = new float[] { 
-                                calculationResult.Sustained.spellMix.RejuvCF * 100,
-                                (calculationResult.Sustained.RejuvCF_unreducedOOM - calculationResult.Sustained.spellMix.RejuvCF) * 100f,
-                                (calculationResult.Sustained.RejuvCF_unreduced - calculationResult.Sustained.RejuvCF_unreducedOOM) * 100
-                            }
-                        };
-                        comparisonList.Add(rejuv);
-                        ComparisonCalculationTree regrowth = new ComparisonCalculationTree()
-                        {
-                            Name = "Regrowth",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.RegrowthCF_unreduced * 100,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.RegrowthCF * 100,
-                            (calculationResult.Sustained.RegrowthCF_unreducedOOM - calculationResult.Sustained.spellMix.RegrowthCF) * 100f,
-                            (calculationResult.Sustained.RegrowthCF_unreduced - calculationResult.Sustained.RegrowthCF_unreducedOOM) * 100}
-                        };
-                        comparisonList.Add(regrowth);
-                        ComparisonCalculationTree managedrejuv = new ComparisonCalculationTree()
-                        {
-                            Name = "Maintained Rejuvenation",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.ManagedRejuvCF_unreduced * 100,
-                            SubPoints = new float[] { 
-                                calculationResult.Sustained.spellMix.ManagedRejuvCF * 100,
-                                (calculationResult.Sustained.ManagedRejuvCF_unreducedOOM - calculationResult.Sustained.spellMix.ManagedRejuvCF) * 100f,
-                                (calculationResult.Sustained.ManagedRejuvCF_unreduced - calculationResult.Sustained.ManagedRejuvCF_unreducedOOM) * 100
-                            }
-                        };
-                        comparisonList.Add(managedrejuv);
-                        ComparisonCalculationTree managedregrowth = new ComparisonCalculationTree()
-                        {
-                            Name = "Maintained Regrowth",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.ManagedRegrowthCF_unreduced * 100,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.ManagedRegrowthCF * 100,
-                            (calculationResult.Sustained.ManagedRegrowthCF_unreducedOOM - calculationResult.Sustained.spellMix.ManagedRegrowthCF) * 100f,
-                            (calculationResult.Sustained.ManagedRegrowthCF_unreduced - calculationResult.Sustained.ManagedRegrowthCF_unreducedOOM) * 100}
-                        };
-                        comparisonList.Add(managedregrowth);
-                        ComparisonCalculationTree lifebloom = new ComparisonCalculationTree()
-                        {
-                            Name = "Lifebloom",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.LifebloomCF_unreduced * 100,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.LifebloomCF * 100,
-                                (calculationResult.Sustained.LifebloomCF_unreducedOOM - calculationResult.Sustained.spellMix.LifebloomCF) * 100f,
-                            (calculationResult.Sustained.LifebloomCF_unreduced - calculationResult.Sustained.LifebloomCF_unreducedOOM) * 100 }
-                        };
-                        comparisonList.Add(lifebloom);
-                        ComparisonCalculationTree lifebloomStack = new ComparisonCalculationTree()
-                        {
-                            Name = "Lifebloom Stack",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.LifebloomStackCF_unreduced * 100,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.LifebloomStackCF * 100, 0,
-                            (calculationResult.Sustained.LifebloomStackCF_unreduced - calculationResult.Sustained.spellMix.LifebloomStackCF) * 100 }
-                        };
-                        comparisonList.Add(lifebloomStack);
-                        ComparisonCalculationTree wildGrowth = new ComparisonCalculationTree()
-                        {
-                            Name = "Wild Growth",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.WildGrowthCF_unreduced * 100,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.WildGrowthCF * 100,
-                                (calculationResult.Sustained.WildGrowthCF_unreducedOOM - calculationResult.Sustained.spellMix.WildGrowthCF) * 100f,
-                            (calculationResult.Sustained.WildGrowthCF_unreduced - calculationResult.Sustained.WildGrowthCF_unreducedOOM) * 100 }
-                        };
-                        comparisonList.Add(wildGrowth);
-                        ComparisonCalculationTree swiftmend = new ComparisonCalculationTree()
-                        {
-                            Name = "Swiftmend",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.SwiftmendCF_unreduced * 100,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.SwiftmendCF * 100, 0,
-                            (calculationResult.Sustained.SwiftmendCF_unreduced - calculationResult.Sustained.spellMix.SwiftmendCF) * 100 }
-                        };
-                        comparisonList.Add(swiftmend);
-                        ComparisonCalculationTree nourish = new ComparisonCalculationTree()
-                        {
-                            Name = "Nourish",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.NourishCF_unreduced * 100,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.NourishCF * 100,
-                                (calculationResult.Sustained.NourishCF_unreducedOOM - calculationResult.Sustained.spellMix.NourishCF) * 100f,
-                            (calculationResult.Sustained.NourishCF_unreduced - calculationResult.Sustained.NourishCF_unreducedOOM) * 100 }
-                        };
-                        comparisonList.Add(nourish);
-                        /*ComparisonCalculationTree idle = new ComparisonCalculationTree()
-                        {
-                            Name = "Idle",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.IdleCF * 100,
-                            SubPoints = new float[] { calculationResult.Sustained.IdleCF_unreduced * 100f,
-                                (calculationResult.Sustained.spellMix.IdleCF - calculationResult.Sustained.IdleCF_unreducedOOM) * 100f,
-                            (calculationResult.Sustained.IdleCF_unreducedOOM - calculationResult.Sustained.IdleCF_unreduced) * 100f }
-                        };
-                        comparisonList.Add(idle);*/
-                    }
-                    return comparisonList.ToArray();
-                #endregion
-                #region Mana usage per spell (sustained)
-                case "Mana usage per spell (sustained)":
-                    {
-                        _subPointNameColors = _subPointNameColorsMPS;
-                        ComparisonCalculationTree rejuv = new ComparisonCalculationTree()
-                        {
-                            Name = "Rejuvenation",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.RejuvMPS,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.RejuvMPS }
-                        };
-                        comparisonList.Add(rejuv);
-                        ComparisonCalculationTree regrowth = new ComparisonCalculationTree()
-                        {
-                            Name = "Regrowth",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.RegrowthMPS,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.RegrowthMPS }
-                        };
-                        comparisonList.Add(regrowth);
-                        ComparisonCalculationTree managedrejuv = new ComparisonCalculationTree()
-                        {
-                            Name = "Maintained Rejuvenation",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.ManagedRejuvMPS,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.ManagedRejuvMPS }
-                        };
-                        comparisonList.Add(managedrejuv);
-                        ComparisonCalculationTree managedregrowth = new ComparisonCalculationTree()
-                        {
-                            Name = "Maintained Regrowth",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.ManagedRegrowthMPS,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.ManagedRegrowthMPS }
-                        };
-                        comparisonList.Add(managedregrowth);
-                        ComparisonCalculationTree lifebloom = new ComparisonCalculationTree()
-                        {
-                            Name = "Lifebloom",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.LifebloomMPS,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.LifebloomMPS }
-                        };
-                        comparisonList.Add(lifebloom);
-                        ComparisonCalculationTree lifebloomStack = new ComparisonCalculationTree()
-                        {
-                            Name = "Lifebloom Stack",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.LifebloomStackMPS,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.LifebloomStackMPS }
-                        };
-                        comparisonList.Add(lifebloomStack);
-                        ComparisonCalculationTree wildGrowth = new ComparisonCalculationTree()
-                        {
-                            Name = "Wild Growth",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.WildGrowthMPS,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.WildGrowthMPS }
-                        };
-                        comparisonList.Add(wildGrowth);
-                        ComparisonCalculationTree swiftmend = new ComparisonCalculationTree()
-                        {
-                            Name = "Swiftmend",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.SwiftmendMPS,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.SwiftmendMPS }
-                        };
-                        comparisonList.Add(swiftmend);
-                        ComparisonCalculationTree primary = new ComparisonCalculationTree()
-                        {
-                            Name = "Nourish",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.NourishMPS,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.NourishMPS }
-                        };
-                        comparisonList.Add(primary);
-                    }
-                    return comparisonList.ToArray();
-                #endregion
-                #region Healing per spell (sustained)
-                case "Total HPS per spell (sustained)":
-                    {
-                        _subPointNameColors = _subPointNameColorsHPS;
-                        ComparisonCalculationTree rejuv = new ComparisonCalculationTree()
-                        {
-                            Name = "Rejuvenation",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.RejuvHPS,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.RejuvHPS }
-                        };
-                        comparisonList.Add(rejuv);
-                        ComparisonCalculationTree regrowth = new ComparisonCalculationTree()
-                        {
-                            Name = "Regrowth",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.RegrowthHPS,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.RegrowthHPS }
-                        };
-                        comparisonList.Add(regrowth);
-                        ComparisonCalculationTree managedrejuv = new ComparisonCalculationTree()
-                        {
-                            Name = "Maintained Rejuvenation",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.ManagedRejuvHPS,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.ManagedRejuvHPS }
-                        };
-                        comparisonList.Add(managedrejuv);
-                        ComparisonCalculationTree managedregrowth = new ComparisonCalculationTree()
-                        {
-                            Name = "Maintained Regrowth",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.ManagedRegrowthHPS,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.ManagedRegrowthHPS }
-                        };
-                        comparisonList.Add(managedregrowth);
-                        ComparisonCalculationTree regrowthDH = new ComparisonCalculationTree()
-                        { // RegrowthAvg * regrowth.HPSHoT + RegrowthCPS * regrowth.AverageHealingwithCrit
-                            Name = "Regrowth (DH)",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.RegrowthCPS * calculationResult.Sustained.spellMix.RegrowthSpell.AverageHealingwithCrit,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.RegrowthCPS * calculationResult.Sustained.spellMix.RegrowthSpell.AverageHealingwithCrit }
-                        };
-                        comparisonList.Add(regrowthDH);
-                        ComparisonCalculationTree regrowthHoT = new ComparisonCalculationTree()
-                        {
-                            Name = "Regrowth (HoT)",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.RegrowthAvg * calculationResult.Sustained.spellMix.RegrowthSpell.HPS_HOT,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.RegrowthAvg * calculationResult.Sustained.spellMix.RegrowthSpell.HPS_HOT }
-                        };
-                        comparisonList.Add(regrowthHoT);
-                        ComparisonCalculationTree managedregrowthDH = new ComparisonCalculationTree()
-                        { // RegrowthAvg * regrowth.HPSHoT + RegrowthCPS * regrowth.AverageHealingwithCrit
-                            Name = "Maintained Regrowth (DH)",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.ManagedRegrowthCPS * calculationResult.Sustained.spellMix.ManagedRegrowthSpell.AverageHealingwithCrit,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.ManagedRegrowthCPS * calculationResult.Sustained.spellMix.ManagedRegrowthSpell.AverageHealingwithCrit }
-                        };
-                        comparisonList.Add(managedregrowthDH);
-                        ComparisonCalculationTree managedregrowthHoT = new ComparisonCalculationTree()
-                        {
-                            Name = "Maintained Regrowth (HoT)",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.ManagedRegrowthAvg * calculationResult.Sustained.spellMix.ManagedRegrowthSpell.HPS_HOT,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.ManagedRegrowthAvg * calculationResult.Sustained.spellMix.ManagedRegrowthSpell.HPS_HOT }
-                        };
-                        comparisonList.Add(managedregrowthHoT);
-                        ComparisonCalculationTree lifebloom = new ComparisonCalculationTree()
-                        {
-                            Name = "Lifebloom",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.LifebloomHPS,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.LifebloomHPS }
-                        };
-                        comparisonList.Add(lifebloom);
-                        ComparisonCalculationTree lifebloomDH = new ComparisonCalculationTree()
-                        {
-                            Name = "Lifebloom (Bloom)",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.LifebloomCPS * calculationResult.Sustained.spellMix.lifebloom.AverageHealingwithCrit,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.LifebloomCPS * calculationResult.Sustained.spellMix.lifebloom.AverageHealingwithCrit }
-                        };
-                        comparisonList.Add(lifebloomDH);
-                        ComparisonCalculationTree lifebloomHoT = new ComparisonCalculationTree()
-                        {
-                            Name = "Lifebloom (HoT)",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.LifebloomAvg * calculationResult.Sustained.spellMix.lifebloom.HPS_HOT,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.LifebloomAvg * calculationResult.Sustained.spellMix.lifebloom.HPS_HOT }
-                        };
-                        comparisonList.Add(lifebloomHoT);
-                        ComparisonCalculationTree lifebloomStack = new ComparisonCalculationTree()
-                        {
-                            Name = "Lifebloom Stack",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.LifebloomStackHPS,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.LifebloomStackHPS }
-                        };
-                        comparisonList.Add(lifebloomStack);
-                        ComparisonCalculationTree lifebloomStackDH = new ComparisonCalculationTree()
-                        {
-                            Name = "Lifebloom Stack (Bloom)",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.LifebloomStackHPS_DH,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.LifebloomStackHPS_DH }
-                        };
-                        comparisonList.Add(lifebloomStackDH);
-                        ComparisonCalculationTree lifebloomStackHOT = new ComparisonCalculationTree()
-                        {
-                            Name = "Lifebloom Stack (HoT)",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.LifebloomStackHPS_HOT,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.LifebloomStackHPS_HOT }
-                        };
-                        comparisonList.Add(lifebloomStackHOT);
-                        ComparisonCalculationTree wildGrowth = new ComparisonCalculationTree()
-                        {
-                            Name = "Wild Growth",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.WildGrowthHPS,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.WildGrowthHPS }
-                        };
-                        comparisonList.Add(wildGrowth);
-                        ComparisonCalculationTree wildGrowthSingle = new ComparisonCalculationTree()
-                        {
-                            Name = "Wild Growth (single target)",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.WildGrowthHPS / calculationResult.Sustained.spellMix.wildGrowth.MaxTargets,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.WildGrowthHPS / calculationResult.Sustained.spellMix.wildGrowth.MaxTargets }
-                        };
-                        comparisonList.Add(wildGrowthSingle);
-                        ComparisonCalculationTree swiftmend = new ComparisonCalculationTree()
-                        {
-                            Name = "Swiftmend",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.SwiftmendHPS,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.SwiftmendHPS }
-                        };
-                        comparisonList.Add(swiftmend);
-                        ComparisonCalculationTree primary = new ComparisonCalculationTree()
-                        {
-                            Name = "Nourish",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.NourishHPS,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.NourishHPS }
-                        };
-                        comparisonList.Add(primary);
-                    }
-                    return comparisonList.ToArray();
-                #endregion
-                #region HPCT per spell
-                case "HPCT per spell":
-                    {
-                        _subPointNameColors = _subPointNameColorsHPCT;
-                        ComparisonCalculationTree rejuv = new ComparisonCalculationTree()
-                        {
-                            Name = "Rejuvenation",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.rejuvenate.HPCT,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.rejuvenate.HPCT, 0, 0 }
-                        };
-                        comparisonList.Add(rejuv);
-                        ComparisonCalculationTree regrowth = new ComparisonCalculationTree()
-                        {
-                            Name = "Regrowth",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.regrowth.HPCT,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.regrowth.HPCT, 0, 0 }
-                        };
-                        comparisonList.Add(regrowth);
-                        ComparisonCalculationTree regrowthAgain = new ComparisonCalculationTree()
-                        {
-                            Name = "Regrowth (chaincast)",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.regrowthAgain.HPCT_DH,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.regrowthAgain.HPCT_DH, 0, 0 }
-                        };
-                        comparisonList.Add(regrowthAgain);
-                        ComparisonCalculationTree lifebloom = new ComparisonCalculationTree()
-                        {
-                            Name = "Lifebloom",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.lifebloom.HPCT,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.lifebloom.HPCT, 0, 0 }
-                        };
-                        comparisonList.Add(lifebloom);
-                        ComparisonCalculationTree lifebloomRollingStack = new ComparisonCalculationTree()
-                        {
-                            Name = "Lifebloom Rolling Stack",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.lifebloomRollingStack.HPCT,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.lifebloomRollingStack.HPCT, 0, 0 }
-                        };
-                        comparisonList.Add(lifebloomRollingStack);
-                        ComparisonCalculationTree lifebloomSlowStack = new ComparisonCalculationTree()
-                        {
-                            Name = "Lifebloom Slow Stack",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.lifebloomSlowStack.HPCT,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.lifebloomSlowStack.HPCT, 0, 0 }
-                        };
-                        comparisonList.Add(lifebloomSlowStack);
-                        ComparisonCalculationTree lifebloomFastStack = new ComparisonCalculationTree()
-                        {
-                            Name = "Lifebloom Fast Stack",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.lifebloomFastStack.HPCT,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.lifebloomFastStack.HPCT, 0, 0 }
-                        };
-                        comparisonList.Add(lifebloomFastStack);
-                        ComparisonCalculationTree lifebloomSlow2Stack = new ComparisonCalculationTree()
-                        {
-                            Name = "Lifebloom Slow x2 Stack",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.lifebloomSlow2Stack.HPCT,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.lifebloomSlow2Stack.HPCT, 0, 0 }
-                        };
-                        comparisonList.Add(lifebloomSlow2Stack);
-                        ComparisonCalculationTree lifebloomFast2Stack = new ComparisonCalculationTree()
-                        {
-                            Name = "Lifebloom Fast x2 Stack",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.lifebloomFast2Stack.HPCT,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.lifebloomFast2Stack.HPCT, 0, 0 }
-                        };
-                        comparisonList.Add(lifebloomFast2Stack);
-                        ComparisonCalculationTree wildGrowth = new ComparisonCalculationTree()
-                        {
-                            Name = "Wild Growth",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.wildGrowth.HPCT,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.wildGrowth.HPCT, 0, 0 }
-                        };
-                        comparisonList.Add(wildGrowth);
-                        ComparisonCalculationTree wildGrowthSingle = new ComparisonCalculationTree()
-                        {
-                            Name = "Wild Growth (single target)",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.wildGrowth.HPCT / calculationResult.Sustained.spellMix.wildGrowth.MaxTargets,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.wildGrowth.HPCT / calculationResult.Sustained.spellMix.wildGrowth.MaxTargets, 0, 0 }
-                        };
-                        comparisonList.Add(wildGrowthSingle);
-                        if (calculationResult.Sustained.spellMix.swiftmend != null)
-                        {
-                            ComparisonCalculationTree swiftmend = new ComparisonCalculationTree()
-                            {
-                                Name = "Swiftmend",
-                                Equipped = false,
-                                OverallPoints = calculationResult.Sustained.spellMix.swiftmend.HPCT,
-                                SubPoints = new float[] { calculationResult.Sustained.spellMix.swiftmend.HPCT, 0, 0 }
-                            };
-                            comparisonList.Add(swiftmend);
-                        }
-                        ComparisonCalculationTree nourish0 = new ComparisonCalculationTree()
-                        {
-                            Name = "Nourish (0)",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.nourish[0].HPCT,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.nourish[0].HPCT, 0, 0 }
-                        };
-                        comparisonList.Add(nourish0);
-                        ComparisonCalculationTree nourish1 = new ComparisonCalculationTree()
-                        {
-                            Name = "Nourish (1)",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.nourish[1].HPCT,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.nourish[1].HPCT, 0, 0 }
-                        };
-                        comparisonList.Add(nourish1);
-                        //ComparisonCalculationTree nourish2 = new ComparisonCalculationTree()
-                        //{
-                        //    Name = "Nourish (2)",
-                        //    Equipped = false,
-                        //    OverallPoints = calculationResult.Sustained.spellMix.nourish[2].HPCT,
-                        //    SubPoints = new float[] { calculationResult.Sustained.spellMix.nourish[2].HPCT }
-                        //};
-                        //comparisonList.Add(nourish2);
-                        //ComparisonCalculationTree nourish3 = new ComparisonCalculationTree()
-                        //{
-                        //    Name = "Nourish (3)",
-                        //    Equipped = false,
-                        //    OverallPoints = calculationResult.Sustained.spellMix.nourish[3].HPCT,
-                        //    SubPoints = new float[] { calculationResult.Sustained.spellMix.nourish[3].HPCT }
-                        //};
-                        //comparisonList.Add(nourish3);
-                        //ComparisonCalculationTree nourish4 = new ComparisonCalculationTree()
-                        //{
-                        //    Name = "Nourish (4)",
-                        //    Equipped = false,
-                        //    OverallPoints = calculationResult.Sustained.spellMix.nourish[4].HPCT,
-                        //    SubPoints = new float[] { calculationResult.Sustained.spellMix.nourish[4].HPCT }
-                        //};
-                        //comparisonList.Add(nourish4);
-                        ComparisonCalculationTree healingTouch = new ComparisonCalculationTree()
-                        {
-                            Name = "Healing Touch",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.healingTouch.HPCT,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.healingTouch.HPCT, 0, 0 }
-                        };
-                        comparisonList.Add(healingTouch);
-                    }
-                    return comparisonList.ToArray();
-                #endregion
-                #region HPS per spell
-                case "HPS per spell":
-                    {
-                        // YES, we use HPCTD here. That's TotalAverageHealing / max(CastTime, Duration)
-                        // with CastTime, that means chaincasting a DH spell (Nourish/HT/SM)
-                        // with Duration, that means refreshing a spell with a HoT component (RG/RJ/LB/WG)
-                        _subPointNameColors = _subPointNameColorsHPS;
-                        ComparisonCalculationTree rejuv = new ComparisonCalculationTree()
-                        {
-                            Name = "Rejuvenation",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.rejuvenate.HPS,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.rejuvenate.HPS, 0, 0 }
-                        };
-                        comparisonList.Add(rejuv);
-                        ComparisonCalculationTree regrowth = new ComparisonCalculationTree()
-                        {
-                            Name = "Regrowth",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.regrowth.HPS,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.regrowth.HPS, 0, 0 }
-                        };
-                        comparisonList.Add(regrowth);
-                        ComparisonCalculationTree regrowthAgain = new ComparisonCalculationTree()
-                        {
-                            Name = "Regrowth (chaincasting)",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.regrowthAgain.HPCT_DH,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.regrowthAgain.HPCT_DH, 0, 0 }
-                        };
-                        comparisonList.Add(regrowthAgain);
-                        ComparisonCalculationTree lifebloom = new ComparisonCalculationTree()
-                        {
-                            Name = "Lifebloom",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.lifebloom.HPS,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.lifebloom.HPS, 0, 0 }
-                        };
-                        comparisonList.Add(lifebloom);
-                        ComparisonCalculationTree lifebloomRollingStack = new ComparisonCalculationTree()
-                        {
-                            Name = "Lifebloom Rolling Stack",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.lifebloomRollingStack.HPS,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.lifebloomRollingStack.HPS, 0, 0 }
-                        };
-                        comparisonList.Add(lifebloomRollingStack);
-                        ComparisonCalculationTree lifebloomSlowStack = new ComparisonCalculationTree()
-                        {
-                            Name = "Lifebloom Slow Stack",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.lifebloomSlowStack.HPS,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.lifebloomSlowStack.HPS, 0, 0 }
-                        };
-                        comparisonList.Add(lifebloomSlowStack);
-                        ComparisonCalculationTree lifebloomFastStack = new ComparisonCalculationTree()
-                        {
-                            Name = "Lifebloom Fast Stack",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.lifebloomFastStack.HPS,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.lifebloomFastStack.HPS, 0, 0 }
-                        };
-                        comparisonList.Add(lifebloomFastStack);
-                        ComparisonCalculationTree lifebloomSlow2Stack = new ComparisonCalculationTree()
-                        {
-                            Name = "Lifebloom Slow x2 Stack",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.lifebloomSlow2Stack.HPS,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.lifebloomSlow2Stack.HPS, 0, 0 }
-                        };
-                        comparisonList.Add(lifebloomSlow2Stack);
-                        ComparisonCalculationTree lifebloomFast2Stack = new ComparisonCalculationTree()
-                        {
-                            Name = "Lifebloom Fast x2 Stack",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.lifebloomFast2Stack.HPS,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.lifebloomFast2Stack.HPS, 0, 0 }
-                        };
-                        comparisonList.Add(lifebloomFast2Stack);
-                        ComparisonCalculationTree wildGrowth = new ComparisonCalculationTree()
-                        {
-                            Name = "Wild Growth",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.wildGrowth.HPS,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.wildGrowth.HPS, 0, 0 }
-                        };
-                        comparisonList.Add(wildGrowth);
-                        ComparisonCalculationTree wildGrowthSingle = new ComparisonCalculationTree()
-                        {
-                            Name = "Wild Growth (single target)",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.wildGrowth.HPS / calculationResult.Sustained.spellMix.wildGrowth.MaxTargets,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.wildGrowth.HPS / calculationResult.Sustained.spellMix.wildGrowth.MaxTargets, 0, 0 }
-                        };
-                        comparisonList.Add(wildGrowthSingle);
-                        if (calculationResult.Sustained.spellMix.swiftmend != null)
-                        {
-                            ComparisonCalculationTree swiftmend = new ComparisonCalculationTree()
-                            {
-                                Name = "Swiftmend",
-                                Equipped = false,
-                                OverallPoints = calculationResult.Sustained.spellMix.swiftmend.HPS,
-                                SubPoints = new float[] { calculationResult.Sustained.spellMix.swiftmend.HPS, 0, 0 }
-                            };
-                            comparisonList.Add(swiftmend);
-                        }
-                        ComparisonCalculationTree nourish0 = new ComparisonCalculationTree()
-                        {
-                            Name = "Nourish (0)",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.nourish[0].HPS,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.nourish[0].HPS, 0, 0 }
-                        };
-                        comparisonList.Add(nourish0);
-                        ComparisonCalculationTree nourish1 = new ComparisonCalculationTree()
-                        {
-                            Name = "Nourish (1)",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.nourish[1].HPS,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.nourish[1].HPS, 0, 0 }
-                        };
-                        comparisonList.Add(nourish1);
-                        //ComparisonCalculationTree nourish2 = new ComparisonCalculationTree()
-                        //{
-                        //    Name = "Nourish (2)",
-                        //    Equipped = false,
-                        //    OverallPoints = calculationResult.Sustained.spellMix.nourish[2].HPS,
-                        //    SubPoints = new float[] { calculationResult.Sustained.spellMix.nourish[2].HPS }
-                        //};
-                        //comparisonList.Add(nourish2);
-                        //ComparisonCalculationTree nourish3 = new ComparisonCalculationTree()
-                        //{
-                        //    Name = "Nourish (3)",
-                        //    Equipped = false,
-                        //    OverallPoints = calculationResult.Sustained.spellMix.nourish[3].HPS,
-                        //    SubPoints = new float[] { calculationResult.Sustained.spellMix.nourish[3].HPS }
-                        //};
-                        //comparisonList.Add(nourish3);
-                        //ComparisonCalculationTree nourish4 = new ComparisonCalculationTree()
-                        //{
-                        //    Name = "Nourish (4)",
-                        //    Equipped = false,
-                        //    OverallPoints = calculationResult.Sustained.spellMix.nourish[4].HPS,
-                        //    SubPoints = new float[] { calculationResult.Sustained.spellMix.nourish[4].HPS }
-                        //};
-                        //comparisonList.Add(nourish4);
-                        ComparisonCalculationTree healingTouch = new ComparisonCalculationTree()
-                        {
-                            Name = "Healing Touch",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.healingTouch.HPS,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.healingTouch.HPS, 0, 0 }
-                        };
-                        comparisonList.Add(healingTouch);
-                    }
-                    return comparisonList.ToArray();
-#endregion
-                #region HPM per spell
-                case "HPM per spell":
-                    {
-                        _subPointNameColors = _subPointNameColorsHPM;
-                        ComparisonCalculationTree rejuv = new ComparisonCalculationTree()
-                        {
-                            Name = "Rejuvenation",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.rejuvenate.HPM,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.rejuvenate.HPM, 0, 0 }
-                        };
-                        comparisonList.Add(rejuv);
-                        ComparisonCalculationTree regrowth = new ComparisonCalculationTree()
-                        {
-                            Name = "Regrowth",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.regrowth.HPM,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.regrowth.HPM, 0, 0 }
-                        };
-                        comparisonList.Add(regrowth);
-                        ComparisonCalculationTree regrowthAgain = new ComparisonCalculationTree()
-                        {
-                            Name = "Regrowth (chaincast)",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.regrowthAgain.HPM_DH,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.regrowthAgain.HPM_DH, 0, 0 }
-                        };
-                        comparisonList.Add(regrowthAgain);
-                        ComparisonCalculationTree lifebloom = new ComparisonCalculationTree()
-                        {
-                            Name = "Lifebloom",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.lifebloom.HPM,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.lifebloom.HPM, 0, 0 }
-                        };
-                        comparisonList.Add(lifebloom);
-                        ComparisonCalculationTree lifebloomRollingStack = new ComparisonCalculationTree()
-                        {
-                            Name = "Lifebloom Rolling Stack",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.lifebloomRollingStack.HPM,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.lifebloomRollingStack.HPM, 0, 0 }
-                        };
-                        comparisonList.Add(lifebloomRollingStack);
-                        ComparisonCalculationTree lifebloomSlowStack = new ComparisonCalculationTree()
-                        {
-                            Name = "Lifebloom Slow Stack",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.lifebloomSlowStack.HPM,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.lifebloomSlowStack.HPM, 0, 0 }
-                        };
-                        comparisonList.Add(lifebloomSlowStack);
-                        ComparisonCalculationTree lifebloomFastStack = new ComparisonCalculationTree()
-                        {
-                            Name = "Lifebloom Fast Stack",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.lifebloomFastStack.HPM,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.lifebloomFastStack.HPM, 0, 0 }
-                        };
-                        comparisonList.Add(lifebloomFastStack);
-                        ComparisonCalculationTree lifebloomSlow2Stack = new ComparisonCalculationTree()
-                        {
-                            Name = "Lifebloom Slow x2 Stack",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.lifebloomSlow2Stack.HPM,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.lifebloomSlow2Stack.HPM, 0, 0 }
-                        };
-                        comparisonList.Add(lifebloomSlow2Stack);
-                        ComparisonCalculationTree lifebloomFast2Stack = new ComparisonCalculationTree()
-                        {
-                            Name = "Lifebloom Fast x2 Stack",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.lifebloomFast2Stack.HPM,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.lifebloomFast2Stack.HPM, 0, 0 }
-                        };
-                        comparisonList.Add(lifebloomFast2Stack);
-                        ComparisonCalculationTree wildGrowth = new ComparisonCalculationTree()
-                        {
-                            Name = "Wild Growth",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.wildGrowth.HPM,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.wildGrowth.HPM, 0, 0 }
-                        };
-                        comparisonList.Add(wildGrowth);
-                        ComparisonCalculationTree wildGrowthSingle = new ComparisonCalculationTree()
-                        {
-                            Name = "Wild Growth (one target)",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.wildGrowth.HPM / calculationResult.Sustained.spellMix.wildGrowth.MaxTargets,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.wildGrowth.HPM / calculationResult.Sustained.spellMix.wildGrowth.MaxTargets, 0, 0 }
-                        };
-                        comparisonList.Add(wildGrowthSingle);
-                        if (calculationResult.Sustained.spellMix.swiftmend != null)
-                        {
-                            ComparisonCalculationTree swiftmend = new ComparisonCalculationTree()
-                            {
-                                Name = "Swiftmend",
-                                Equipped = false,
-                                OverallPoints = calculationResult.Sustained.spellMix.swiftmend.HPM,
-                                SubPoints = new float[] { calculationResult.Sustained.spellMix.swiftmend.HPM, 0, 0 }
-                            };
-                            comparisonList.Add(swiftmend);
-                        }
-                        ComparisonCalculationTree nourish0 = new ComparisonCalculationTree()
-                        {
-                            Name = "Nourish (0)",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.nourish[0].HPM,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.nourish[0].HPM, 0, 0 }
-                        };
-                        comparisonList.Add(nourish0);
-                        ComparisonCalculationTree nourish1 = new ComparisonCalculationTree()
-                        {
-                            Name = "Nourish (1)",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.nourish[1].HPM,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.nourish[1].HPM, 0, 0 }
-                        };
-                        comparisonList.Add(nourish1);
-                        //ComparisonCalculationTree nourish2 = new ComparisonCalculationTree()
-                        //{
-                        //    Name = "Nourish (2)",
-                        //    Equipped = false,
-                        //    OverallPoints = calculationResult.Sustained.spellMix.nourish[2].HPM,
-                        //    SubPoints = new float[] { calculationResult.Sustained.spellMix.nourish[2].HPM }
-                        //};
-                        //comparisonList.Add(nourish2);
-                        //ComparisonCalculationTree nourish3 = new ComparisonCalculationTree()
-                        //{
-                        //    Name = "Nourish (3)",
-                        //    Equipped = false,
-                        //    OverallPoints = calculationResult.Sustained.spellMix.nourish[3].HPM,
-                        //    SubPoints = new float[] { calculationResult.Sustained.spellMix.nourish[3].HPM }
-                        //};
-                        //comparisonList.Add(nourish3);
-                        //ComparisonCalculationTree nourish4 = new ComparisonCalculationTree()
-                        //{
-                        //    Name = "Nourish (4)",
-                        //    Equipped = false,
-                        //    OverallPoints = calculationResult.Sustained.spellMix.nourish[4].HPM,
-                        //    SubPoints = new float[] { calculationResult.Sustained.spellMix.nourish[4].HPM }
-                        //};
-                        //comparisonList.Add(nourish4);
-                        ComparisonCalculationTree healingTouch = new ComparisonCalculationTree()
-                        {
-                            Name = "Healing Touch",
-                            Equipped = false,
-                            OverallPoints = calculationResult.Sustained.spellMix.healingTouch.HPM,
-                            SubPoints = new float[] { calculationResult.Sustained.spellMix.healingTouch.HPM, 0, 0 }
-                        };
-                        comparisonList.Add(healingTouch);
-                    }
-                    return comparisonList.ToArray();
-#endregion
-                #region Healing per spell (single target)
-                case "Healing per spell (single target)":
-                    {
-                        _subPointNameColors = _subPointNameColorsHPS;
-                        ComparisonCalculationTree rejuv = new ComparisonCalculationTree()
-                        {
-                            Name = "Rejuvenation",
-                            Equipped = false,
-                            OverallPoints = calculationResult.SingleTarget[0].spellMix.RejuvHPS,
-                            SubPoints = new float[] { calculationResult.SingleTarget[0].spellMix.RejuvHPS }
-                        };
-                        comparisonList.Add(rejuv);
-                        ComparisonCalculationTree regrowth = new ComparisonCalculationTree()
-                        {
-                            Name = "Regrowth",
-                            Equipped = false,
-                            OverallPoints = calculationResult.SingleTarget[0].spellMix.RegrowthHPS,
-                            SubPoints = new float[] { calculationResult.SingleTarget[0].spellMix.RegrowthHPS }
-                        };
-                        comparisonList.Add(regrowth);
-                        ComparisonCalculationTree lifebloomStack = new ComparisonCalculationTree()
-                        {
-                            Name = "Lifebloom Stack",
-                            Equipped = false,
-                            OverallPoints = calculationResult.SingleTarget[0].spellMix.LifebloomStackHPS,
-                            SubPoints = new float[] { calculationResult.SingleTarget[0].spellMix.LifebloomStackHPS }
-                        };
-                        comparisonList.Add(lifebloomStack);
-                        if (calculationResult.Sustained.spellMix.swiftmend != null)
-                        {
-                            ComparisonCalculationTree swiftmend = new ComparisonCalculationTree()
-                            {
-                                Name = "Swiftmend",
-                                Equipped = false,
-                                OverallPoints = calculationResult.SingleTarget[0].spellMix.SwiftmendHPS,
-                                SubPoints = new float[] { calculationResult.SingleTarget[0].spellMix.SwiftmendHPS }
-                            };
-                            comparisonList.Add(swiftmend);
-                        }
-                        ComparisonCalculationTree primary = new ComparisonCalculationTree()
-                        {
-                            Name = "Nourish",
-                            Equipped = false,
-                            OverallPoints = calculationResult.SingleTarget[0].spellMix.NourishHPS,
-                            SubPoints = new float[] { calculationResult.SingleTarget[0].spellMix.NourishHPS }
-                        };
-                        comparisonList.Add(primary);
-                    }
-                    return comparisonList.ToArray();
-                    #endregion
-                #region Single Target spell mixes (HPS)
-                case "Single target spell mixes (HPS)":
-                    {
-                        _subPointNameColors = _subPointNameColorsHPS;
-                        for (int i = 2; i < 20; i++)
-                        {
+					chart.Add(Calculations.GetCharacterComparisonCalculations(calcsBase, calcsCur, String.Format("{0,4:F0}", hb), false, false));
+				}
 
-                            ComparisonCalculationTree spell = new ComparisonCalculationTree()
-                            {
-                                Name = Solver.SingleTargetRotationToText(calculationResult.SingleTarget[i].rotation),
-                                Equipped = false,
-                                OverallPoints = calculationResult.SingleTarget[i].HPS,
-                                SubPoints = new float[] { calculationResult.SingleTarget[i].HPS }
-                            };
-                            comparisonList.Add(spell);
-                        }
-                    }
-                    return comparisonList.ToArray();
-                #endregion
-                #region Single Target spell mixes (HPM)
-                case "Single target spell mixes (HPM)":
-                    {
-                        _subPointNameColors = _subPointNameColorsHPM;
-                        for (int i = 2; i < 20; i++)
-                        {
+				if(!curIsBreakpoint)
+					chart.Add(Calculations.GetCharacterComparisonCalculations(calcsBase, calcsBase, String.Format("{0,4:F0} (-)", calcsBase.BasicStats.HasteRating), true, false));
 
-                            ComparisonCalculationTree spell = new ComparisonCalculationTree()
-                            {
-                                Name = Solver.SingleTargetRotationToText(calculationResult.SingleTarget[i].rotation),
-                                Equipped = false,
-                                OverallPoints = calculationResult.SingleTarget[i].HPM,
-                                SubPoints = new float[] { calculationResult.SingleTarget[i].HPM }
-                            };
-                            comparisonList.Add(spell);
-                        }
-                    }
-                    return comparisonList.ToArray();
-                #endregion
-                #region Single Target spell mixes (MPS)
-                case "Single target spell mixes (MPS)":
-                    {
-                        _subPointNameColors = _subPointNameColorsMPS;
-                        for (int i = 2; i < 20; i++)
-                        {
+				return chart.ToArray();
+			}
+		}
 
-                            ComparisonCalculationTree spell = new ComparisonCalculationTree()
-                            {
-                                Name = Solver.SingleTargetRotationToText(calculationResult.SingleTarget[i].rotation),
-                                Equipped = false,
-                                OverallPoints = calculationResult.SingleTarget[i].spellMix.MPS,
-                                SubPoints = new float[] { calculationResult.SingleTarget[i].spellMix.MPS }
-                            };
-                            comparisonList.Add(spell);
-                        }
-                    }
-                    return comparisonList.ToArray();
-                    
-                #endregion
-                #region HPM per rotation
-                case "New HPM per rotation":
-                     _subPointNameColors = _subPointNameColorsHPM;
-                     for (int i = 0; i < 25; i++)
-                     {
-                         Rotation rot = new Rotation(i, character, calculationResult.CombatStats, boss);
-                         ComparisonCalculationTree tmp = new ComparisonCalculationTree()
-                         {
-                             Name = rot.Name,
-                             OverallPoints = rot.HPM,
-                             SubPoints = new float[] { rot.HPM, 0, 0 }
-                         };
-                         comparisonList.Add(tmp);
-                     }
-                     for (int i = 100; i < customRotationsMax; i++)
-                    {
-                        Rotation rot = new Rotation(i, character, calculationResult.CombatStats, boss);
-                        ComparisonCalculationTree tmp = new ComparisonCalculationTree()
-                        {
-                            Name = rot.Name,
-                            OverallPoints = rot.HPM,
-                            SubPoints = new float[] { rot.HPM, 0, 0 },
-                            PartEquipped = true,
-
-                        };
-                        comparisonList.Add(tmp);
-                    }
-                    return comparisonList.ToArray();
-                #endregion
-                #region HPS per rotation
-                case "New HPS per rotation":
-                     _subPointNameColors = _subPointNameColorsHPS;
-                     for (int i = 0; i < 25; i++)
-                     {
-                         Rotation rot = new Rotation(i, character, calculationResult.CombatStats, boss);
-                         ComparisonCalculationTree tmp = new ComparisonCalculationTree()
-                         {
-                             Name = rot.Name,
-                             OverallPoints = rot.HPS,
-                             SubPoints = new float[] { rot.HPS, 0, 0 }
-                         };
-                         comparisonList.Add(tmp);
-                     }
-                     for (int i = 100; i < customRotationsMax; i++)
-                     {
-                         Rotation rot = new Rotation(i, character, calculationResult.CombatStats, boss);
-                         ComparisonCalculationTree tmp = new ComparisonCalculationTree()
-                         {
-                             Name = rot.Name,
-                             OverallPoints = rot.HPS,
-                             SubPoints = new float[] { rot.HPS, 0, 0 },
-                             PartEquipped = true,
-                         };
-                         comparisonList.Add(tmp);
-                     }
-                    return comparisonList.ToArray();
-                #endregion
-                #region MPS per rotation
-                case "New MPS per rotation":
-                    _subPointNameColors = _subPointNameColorsMPS;
-                    for (int i = 0; i < 25; i++)
-                    {
-                        Rotation rot = new Rotation(i, character, calculationResult.CombatStats, boss);
-                        ComparisonCalculationTree tmp = new ComparisonCalculationTree()
-                        {
-                            Name = rot.Name,
-                            OverallPoints = rot.MPS,
-                            SubPoints = new float[] { rot.MPS, 0, 0 }
-                        };
-                        comparisonList.Add(tmp);
-                    }
-
-                    for (int i = 100; i < customRotationsMax; i++)
-                    {
-                        Rotation rot = new Rotation(i, character, calculationResult.CombatStats, boss);
-                        ComparisonCalculationTree tmp = new ComparisonCalculationTree()
-                        {
-                            Name = rot.Name,
-                            OverallPoints = rot.MPS,
-                            SubPoints = new float[] { rot.MPS, 0, 0 },
-                              PartEquipped = true,
-                       };
-                        comparisonList.Add(tmp);
-                    }
-
-                    return comparisonList.ToArray();
-                #endregion
-                default:
-                    return new ComparisonCalculationBase[0];
-            }
-        }
-
-        public override Stats GetRelevantStats(Stats stats) {
-            Stats s = new Stats() {
-                #region Base Stats
-                //Stamina = stats.Stamina,
-                Intellect = stats.Intellect,
-                Spirit = stats.Spirit,
-                SpellPower = stats.SpellPower,
-                CritRating = stats.CritRating,
-                HasteRating = stats.HasteRating,
-                SpellHaste = stats.SpellHaste,
-                SpellCrit = stats.SpellCrit,
-                MasteryRating = stats.MasteryRating,
-                //Health = stats.Health,
-                Mana = stats.Mana,
-                Mp5 = stats.Mp5,
-                Armor = stats.Armor,
-                Stamina = stats.Stamina,
-                ManaRestoreFromMaxManaPerSecond = stats.ManaRestoreFromMaxManaPerSecond,
-                MovementSpeed = stats.MovementSpeed,
-                SnareRootDurReduc = stats.SnareRootDurReduc,
-                FearDurReduc = stats.FearDurReduc,
-                StunDurReduc = stats.StunDurReduc,
-                BonusHealingDoneMultiplier = stats.BonusHealingDoneMultiplier,
-                #endregion
-                #region Trinkets
-                HighestStat = stats.HighestStat,
-                SpellsManaCostReduction = stats.SpellsManaCostReduction,
-                NatureSpellsManaCostReduction = stats.NatureSpellsManaCostReduction,
-                #endregion
-                #region Gems
-                BonusCritHealMultiplier = stats.BonusCritHealMultiplier,
-                BonusManaMultiplier = stats.BonusManaMultiplier,
-                BonusIntellectMultiplier = stats.BonusIntellectMultiplier,
-                #endregion
-            };
-            foreach (Rawr.SpecialEffect effect in stats.SpecialEffects()) {
-                if (effect.Trigger == Trigger.Use || 
-                    effect.Trigger == Trigger.SpellCast || effect.Trigger == Trigger.SpellCrit || effect.Trigger == Trigger.SpellHit
-                    || effect.Trigger == Trigger.HealingSpellCast || effect.Trigger == Trigger.HealingSpellCrit || effect.Trigger == Trigger.HealingSpellHit
-                    )
-                {
-                    if (HasRelevantSpecialEffectStats(effect.Stats)) {
-                        s.AddSpecialEffect(effect);
-                    } else {
-                        // Trigger seems relevant, but effect not. Sounds weird, probably DPS bonus on Use or general SpellCast ...
-                    }
-                }
-            }
-            return s;
-        }
-        public bool HasRelevantSpecialEffectStats(Stats stats) {
-            foreach (Rawr.SpecialEffect effect in stats.SpecialEffects())
-            {
-                if (effect.Trigger == Trigger.Use ||
-                    effect.Trigger == Trigger.SpellCast || effect.Trigger == Trigger.SpellCrit
-                    || effect.Trigger == Trigger.HealingSpellCast || effect.Trigger == Trigger.HealingSpellCrit || effect.Trigger == Trigger.HealingSpellHit
-                    )
-                {
-                    if (HasRelevantSpecialEffectStats(effect.Stats)) return true;
-                }
-            }
-            return (stats.Intellect + stats.Spirit + stats.SpellPower + stats.CritRating + stats.HasteRating + stats.ManaRestore + stats.MasteryRating
-                   + stats.Mp5 + stats.Healed + stats.HighestStat + stats.BonusHealingReceived
-                   + stats.ShieldFromHealedProc + stats.ManaRestoreFromMaxManaPerSecond
-                   + stats.SnareRootDurReduc + stats.FearDurReduc + stats.StunDurReduc + stats.MovementSpeed) != 0;
-        }
-        public override bool HasRelevantStats(Stats stats) {
-            if (HasRelevantSpecialEffectStats(stats)) return true;
-
-            if (stats.Intellect + stats.Spirit + stats.Mp5 + stats.SpellPower + stats.Mana + stats.CritRating + stats.SpellCrit + stats.MasteryRating
-                + stats.HasteRating + stats.SpellHaste + stats.BonusSpellPowerMultiplier
-                + stats.BonusSpiritMultiplier + stats.BonusIntellectMultiplier + stats.BonusStaminaMultiplier
-                + stats.BonusCritHealMultiplier + stats.BonusManaMultiplier
-                /*+ stats.Armor + stats.Stamina*/ + stats.ManaRestoreFromMaxManaPerSecond
-                + stats.MovementSpeed + stats.SpellCombatManaRegeneration // Bangle of nerfed - might be useful in future
-                + stats.SnareRootDurReduc + stats.FearDurReduc + stats.StunDurReduc
-                + stats.BonusHealingDoneMultiplier
-                #region Trinkets
-                + stats.HighestStat + stats.SpellsManaCostReduction + stats.NatureSpellsManaCostReduction
-                #endregion
-                != 0)
-                return true;
-
-            return false;
-        }
-        public Stats GetBuffsStats(Character character, CalculationOptionsTree calcOpts) {
-            List<Buff> removedBuffs = new List<Buff>();
-            List<Buff> addedBuffs = new List<Buff>();
-
-            //float hasRelevantBuff;
-
-            #region Passive Ability Auto-Fixing
-            // Removes the Trueshot Aura Buff and it's equivalents Unleashed Rage and Abomination's Might if you are
-            // maintaining it yourself. We are now calculating this internally for better accuracy and to provide
-            // value to relevant talents
-            /*{
-                hasRelevantBuff = character.HunterTalents.TrueshotAura;
-                Buff a = Buff.GetBuffByName("Trueshot Aura");
-                Buff b = Buff.GetBuffByName("Unleashed Rage");
-                Buff c = Buff.GetBuffByName("Abomination's Might");
-                if (hasRelevantBuff > 0)
-                {
-                    if (character.ActiveBuffs.Contains(a)) { character.ActiveBuffs.Remove(a); removedBuffs.Add(a); }
-                    if (character.ActiveBuffs.Contains(b)) { character.ActiveBuffs.Remove(b); removedBuffs.Add(b); }
-                    if (character.ActiveBuffs.Contains(c)) { character.ActiveBuffs.Remove(c); removedBuffs.Add(c); }
-                }
-            }
-            // Removes the Hunter's Mark Buff and it's Children 'Glyphed', 'Improved' and 'Both' if you are
-            // maintaining it yourself. We are now calculating this internally for better accuracy and to provide
-            // value to relevant talents
-            {
-                hasRelevantBuff =  character.HunterTalents.ImprovedHuntersMark
-                                + (character.HunterTalents.GlyphOfHuntersMark ? 1 : 0);
-                Buff a = Buff.GetBuffByName("Hunter's Mark");
-                Buff b = Buff.GetBuffByName("Glyphed Hunter's Mark");
-                Buff c = Buff.GetBuffByName("Improved Hunter's Mark");
-                Buff d = Buff.GetBuffByName("Improved and Glyphed Hunter's Mark");
-                // Since we are doing base Hunter's mark ourselves, we still don't want to double-dip
-                if (character.ActiveBuffs.Contains(a)) { character.ActiveBuffs.Remove(a); /*removedBuffs.Add(a);*//* }
-                // If we have an enhanced Hunter's Mark, kill the Buff
-                if (hasRelevantBuff > 0) {
-                    if (character.ActiveBuffs.Contains(b)) { character.ActiveBuffs.Remove(b); /*removedBuffs.Add(b);*//* }
-                    if (character.ActiveBuffs.Contains(c)) { character.ActiveBuffs.Remove(c); /*removedBuffs.Add(c);*//* }
-                    if (character.ActiveBuffs.Contains(d)) { character.ActiveBuffs.Remove(d); /*removedBuffs.Add(c);*//* }
-                }
-            }*/
-            /* [More Buffs to Come to this method]
-             * Ferocious Inspiration | Sanctified Retribution
-             * Hunting Party | Judgements of the Wise, Vampiric Touch, Improved Soul Leech, Enduring Winter
-             * Acid Spit | Expose Armor, Sunder Armor (requires BM & Worm Pet)
-             */
-            #endregion
-
-            Stats statsBuffs = GetBuffsStats(character.ActiveBuffs, character.SetBonusCount);
-
-            foreach (Buff b in removedBuffs) {
-                character.ActiveBuffsAdd(b);
-            }
-            foreach (Buff b in addedBuffs) {
-                character.ActiveBuffs.Remove(b);
-            }
-
-            return statsBuffs;
-        }
-        // Wildebees 20090407 : Overload base function to disable all enchants on OffHand for tree druids
-        public override bool EnchantFitsInSlot(Enchant enchant, Character character, ItemSlot slot) {
-            if (slot == ItemSlot.OffHand) { return false; }
-            return base.EnchantFitsInSlot(enchant, character, slot);
-        }
-
-        public override ICalculationOptionBase DeserializeDataObject(string xml)
-        {
-            XmlSerializer serializer = new XmlSerializer(typeof(CalculationOptionsTree));
-            StringReader reader = new StringReader(xml);
-            CalculationOptionsTree calcOpts = serializer.Deserialize(reader) as CalculationOptionsTree;
-            return calcOpts;
-        }
-    }
-
+		#endregion
+	}
 }
Index: Rawr.Tree/CharacterCalculationsTree.cs
===================================================================
--- Rawr.Tree/CharacterCalculationsTree.cs	(revision 60557)
+++ Rawr.Tree/CharacterCalculationsTree.cs	(working copy)
@@ -1,251 +1,369 @@
 ï»¿using System;
 using System.Collections.Generic;
+using System.Text;
 
 namespace Rawr.Tree {
-    public class CharacterCalculationsTree : CharacterCalculationsBase {
-        public Stats BasicStats { get; set; }
-        public Stats CombatStats { get; set; }
+	enum TreeAction
+	{
+		RaidReLifebloom,
+		RaidWildGrowth,
+		RaidSwiftmend,
+		RaidRejuvenation,
+		RaidHealingTouch,
+		RaidNourish,
+		RaidRj2NourishNB,
+		RaidRj3NourishNB,
+		RaidRegrowth,
+		RaidClearHT,
+		RaidClearRegrowth,
+		RaidSwiftHT,
+		RaidTranquility,
+		RaidTolLb,
+		RaidTolLbCcHt,
 
-        private float[] subPoints = new float[] { 0f, 0f, 0f };
-        public override float[] SubPoints {
-            get { return subPoints; }
-            set { subPoints = value; }
-        }
-        public float SingleTargetPoints {
-            get { return subPoints[0]; }
-            set { subPoints[0] = value; }
-        }
-        public float SustainedPoints {
-            get { return subPoints[1]; }
-            set { subPoints[1] = value; }
-        }
-        public float SurvivalPoints {
-            get { return subPoints[2]; }
-            set { subPoints[2] = value; }
-        } 
-        public override float OverallPoints { get; set; }
-        public SustainedResult Sustained;
-        public SingleTargetBurstResult[] SingleTarget;
-        public Character LocalCharacter { get; set; }
-        public BossOptions boss;
-        public float SingleTargetHPS;
-        public float SustainedHPS;
-        public float SpellPower;
+		TankReLifebloom,
+		TankWildGrowth,
+		TankSwiftmend,
+		TankRejuvenation,
+		TankHealingTouch,
+		TankNourish,
+		TankRj2NourishNB,
+		TankRegrowth,
+		TankClearHT,
+		TankClearRegrowth,
+		TankSwiftHT,
+		TankTolLbCcHt, // the LB is on the raid, but the CCHT is on the tank
 
-        string LifebloomMethod_ToString(int lbStack, LifeBloomType type) {
-            string result;
-            if (type == LifeBloomType.Fast)
-            {
-                switch (lbStack)
-                {
-                    case 0: result = "Unused"; break;
-                    case 1: result = "Single blooms"; break;
-                    case 2: result = "Fast Double blooms"; break;
-                    case 3: result = "Fast Triple blooms"; break;
-                    case 4:
-                    default: result = "Stack"; break;
-                }
-            }
-            else if (type == LifeBloomType.Slow)
-            {
-                switch (lbStack)
-                {
-                    case 0: result = "Unused"; break;
-                    case 1: result = "Single blooms"; break;
-                    case 2: result = "Slow Double blooms"; break;
-                    case 3: result = "Slow Triple blooms"; break;
-                    case 4:
-                    default: result = "Stack"; break;
-                }
-            }
-            else result = "Rolling stack";
+		Count
+	};
 
-            return result;
-        }
+	public class TreeStats
+	{
+		public DruidTalents Talents;
+		public bool Restoration;
 
-        public override Dictionary<string, string> GetCharacterDisplayCalculationValues() {
-            Dictionary<string, string> dictValues = new Dictionary<string, string>();
+		public double SpellPower;
+		public double SpellCrit;
 
-            dictValues.Add("Single Target Points", SingleTargetPoints.ToString());
-            dictValues.Add("Sustained Points", SustainedPoints.ToString());
-            dictValues.Add("Survival Points", SurvivalPoints.ToString());
-            dictValues.Add("Overall Points", OverallPoints.ToString());
+		public double HasteRating;
+		public double SpellHaste;
+		public double[] HasteProcUptimes;
+		public int[] HasteProcRatings;
+		public double[] HasteProcMultipliers;
+		public double HastedSecond;
+		public double HastedInstantCastMS;
 
-            dictValues.Add("Base Health", BasicStats.Health.ToString());
-            dictValues.Add("Base Armor", Math.Round(BasicStats.Armor, 0) + "*Reduces damage taken by " + Math.Round(StatConversion.GetArmorDamageReduction(88, BasicStats.Armor, 0, 0/*, 0*/) * 100.0f, 2) + "%");
-            dictValues.Add("Base Mana", BasicStats.Mana.ToString());
-            dictValues.Add("Base Stamina", BasicStats.Stamina.ToString());
-            dictValues.Add("Base Intellect", BasicStats.Intellect.ToString());
-            dictValues.Add("Base Spirit", BasicStats.Spirit.ToString());
-            dictValues.Add("Base Spell Power", (BasicStats.SpellPower).ToString() /* This should be 151 + Int (at least for a Tauren) + "*" + BasicStats.Spirit * LocalCharacter.DruidTalents.ImprovedTreeOfLife * 0.05f + " from Improved Tree of Life" */);
-            dictValues.Add("Base Spell Crit", Math.Round(BasicStats.SpellCrit * 100.0f,2).ToString());
-            dictValues.Add("Base Mastery", String.Format("{0:F}*{1} Rating\n {2} % bonus healing", TreeConstants.Mastery(BasicStats), BasicStats.MasteryRating, Math.Round(TreeConstants.Symbiosis(BasicStats)*100.0f,2)));
+		public double TreeOfLifeUptime;
+		public double Symbiosis;
+		public double Harmony;
 
-            float speed_from_hr = (1f + StatConversion.GetSpellHasteFromRating(BasicStats.HasteRating));
-            float speed_from_sh = (1f + BasicStats.SpellHaste);
-            float speed = speed_from_hr * speed_from_sh;
-            float hard = (1.5f / (1f * speed_from_sh) - 1) * StatConversion.RATING_PER_SPELLHASTE;
-            float untilcap = hard - BasicStats.HasteRating;
+		public double SpellsManaCostReduction;
+		public double BonusCritHealMultiplier;
 
-            float speed_step = (float)(Math.Round(4.0f * speed) + 0.5f) / 4.0f;
-            float speed_needed_rejuv = speed_step - speed;
-            float haste_until_rejuv_step = speed_needed_rejuv * StatConversion.RATING_PER_SPELLHASTE;
-            speed_step = (float)(Math.Round(10.0f * speed) + 0.5f) / 10.0f;
-            float speed_needed_lb = speed_step - speed;
-            float haste_until_lb_step = speed_needed_lb * StatConversion.RATING_PER_SPELLHASTE;
+		public double computeHoT(int baseTickRateMS, int baseDurationMS)
+		{
+			double durationMS, tpms;
+			return computeHoT(baseTickRateMS, baseDurationMS, out durationMS, out tpms);
+		}
 
-            dictValues.Add("Base Spell Haste", Math.Round((speed - 1.0f) * 100.0f, 2) + "%*" + Math.Round((speed_from_sh - 1.0f) * 100.0f, 2) + "% from spell effects and talents\n" + Math.Round((speed_from_hr - 1.0f) * 100.0f, 2) + "% from " + BasicStats.HasteRating + " haste rating \n" + Math.Round(haste_until_rejuv_step) + " haste rating (" + Math.Round(speed_needed_rejuv * 100.0, 1) + "%) until next rejuv tick\n" + Math.Round(haste_until_lb_step) + " haste rating (" + Math.Round(speed_needed_lb * 100.0, 1) + "%) until next lifebloom tick");
-            // Use Nourish gcd to equal normal GCD
-            Spell spell = new Nourish(LocalCharacter, BasicStats);
-            dictValues.Add("Base Global CD", Math.Round(spell.gcd, 2) + " sec*" + Math.Ceiling(untilcap).ToString() + " Haste Rating until hard gcd cap");
+		public double computeHoT(int baseTickRateMS, int baseDurationMS, out double durationMS)
+		{
+			double tpms;
+			return computeHoT(baseTickRateMS, baseDurationMS, out durationMS, out tpms);
+		}
 
-            ManaPool manaPool = new ManaPool(CombatStats, boss.BerserkTimer);
-            dictValues.Add("Health", CombatStats.Health.ToString());
-            dictValues.Add("Armor", Math.Round(CombatStats.Armor, 0) + "*Reduces damage taken by " + Math.Round(StatConversion.GetArmorDamageReduction(88, CombatStats.Armor, 0, 0) * 100.0f, 2) + "%");
-            dictValues.Add("Mana", CombatStats.Mana.ToString() + "*" + manaPool.ToString());
-            dictValues.Add("Stamina", CombatStats.Stamina.ToString());
-            dictValues.Add("Intellect", CombatStats.Intellect.ToString());
-            dictValues.Add("Spirit", CombatStats.Spirit.ToString());
-            dictValues.Add("Spell Power", (CombatStats.SpellPower).ToString() /* + "*" + CombatStats.Spirit * LocalCharacter.DruidTalents.ImprovedTreeOfLife * 0.05f + " from Improved Tree of Life" */);
-            dictValues.Add("Spell Crit", Math.Round(CombatStats.SpellCrit * 100.0f, 2).ToString());
-            dictValues.Add("Mastery", String.Format("{0:F}*{1} Rating\n {2} % bonus healing", TreeConstants.Mastery(CombatStats), CombatStats.MasteryRating, Math.Round(TreeConstants.Symbiosis(CombatStats) * 100.0f, 2)));
+		public double computeHoT(int baseTickRateMS, int baseDurationMS, out double durationMS, out double tpms)
+		{
+			//tickRateMS = 0;
+			double ticks = 0;
+			tpms = 0;
+			durationMS = 0;
 
-            speed_from_hr = (1f + StatConversion.GetSpellHasteFromRating(CombatStats.HasteRating));
-            speed_from_sh = (1f + CombatStats.SpellHaste);
-            speed = speed_from_hr * speed_from_sh;
-            hard = (1.5f / (1f * speed_from_sh) - 1) * StatConversion.RATING_PER_SPELLHASTE;
-            untilcap = hard - CombatStats.HasteRating;
-            speed_step = (float) (Math.Round(4.0f * speed) + 0.5f) / 4.0f;
-            speed_needed_rejuv = speed_step - speed;
-            haste_until_rejuv_step = speed_needed_rejuv * StatConversion.RATING_PER_SPELLHASTE;
-            speed_step = (float)(Math.Round(10.0f * speed) + 0.5f) / 10.0f;
-            speed_needed_lb = speed_step - speed;
-            haste_until_lb_step = speed_needed_lb * StatConversion.RATING_PER_SPELLHASTE;
+			int n = HasteProcUptimes.Length;
+			int maxmask = 1 << n;
+			for (int i = 0; i < maxmask; ++i)
+			{
+				int hasteRating = 0;
+				double hasteFactor = (1 + SpellHaste);
+				double fraction = 1.0;
+				for (int j = 0; j < n; ++j)
+				{
+					if ((i & (1 << j)) != 0)
+					{
+						hasteRating += HasteProcRatings[j];
+						hasteFactor *= HasteProcMultipliers[j];
+						fraction *= HasteProcUptimes[j];
+					}
+					else
+						fraction *= 1 - HasteProcUptimes[j];
+				}
 
+				double hasteRatingMult = 1.0f + StatConversion.GetSpellHasteFromRating((float)(HasteRating + hasteRating));
+				hasteFactor *= hasteRatingMult;
+				double curTickRateMS = baseTickRateMS / hasteFactor;
+				double curTicks = (double)Math.Ceiling(baseDurationMS / (double)Math.Round(curTickRateMS) - 0.5f);
 
-            dictValues.Add("Spell Haste", Math.Round((speed - 1.0f) * 100.0f, 2) + "%*" + Math.Round((speed_from_sh - 1.0f) * 100.0f, 2) + "% from spell effects and talents\n" + Math.Round((speed_from_hr - 1.0f) * 100.0f, 2) + "% from " + CombatStats.HasteRating + " haste rating \n" + Math.Round(haste_until_rejuv_step) + " haste rating (" + Math.Round(speed_needed_rejuv * 100.0, 1) + "%) until next rejuv tick\n" + Math.Round(haste_until_lb_step) + " haste rating (" + Math.Round(speed_needed_lb * 100.0, 1) + "%) until next lifebloom tick");
-            // Use Nourish gcd to equal normal GCD
-            spell = Sustained.spellMix.nourish[0];
-            dictValues.Add("Global CD", Math.Round(spell.gcd, 2) + " sec*" + Math.Ceiling(untilcap).ToString() + " Haste Rating until soft gcd cap");
+				//tickRateMS += fraction * curTickRateMS;
+				ticks += fraction * curTicks;
+				tpms += fraction * (1.0 / curTickRateMS);
+				durationMS += fraction * curTicks * curTickRateMS;
+			}
+			return ticks;
+		}
 
-            dictValues.Add("Boss Name", boss.Name + "*" + boss.ToString()); 
-            dictValues.Add("Total Time", Math.Round(Sustained.TotalTime, 2).ToString());
-  //          dictValues.Add("Time until OOM (unreduced)", Math.Round(Sustained.TimeToOOM_unreduced, 2).ToString());
-  //          dictValues.Add("Time until OOM", Math.Round(Sustained.TimeToOOM, 2).ToString());
-            dictValues.Add("Total healing done", Math.Round(Sustained.TotalTime * SustainedHPS, 2).ToString()); // Has extra component from procs
-            dictValues.Add("Sustained HPS", Math.Round(SustainedHPS, 2).ToString());
-            dictValues.Add("Single Target HPS", Math.Round(SingleTargetHPS, 2).ToString());
-            dictValues.Add("Mana regen per second", Math.Round(Sustained.ManaRegen, 2).ToString());
-            dictValues.Add("Mana from innervates", Math.Round(Sustained.InnervateMana, 2).ToString());
-            dictValues.Add("Average casts per minute", Math.Round(Sustained.spellMix.CastsPerMinute, 2).ToString());
-            dictValues.Add("Average crits per minute", Math.Round(Sustained.spellMix.CritsPerMinute, 2).ToString());
-            dictValues.Add("Average heals per minute", Math.Round(Sustained.spellMix.HealsPerMinute, 2).ToString());
-            dictValues.Add("Rejuvenation casts per minute", Math.Round(Sustained.spellMix.RejuvCPM, 2).ToString());
-            dictValues.Add("Rejuvenation average up", Math.Round(Sustained.spellMix.RejuvAvg, 2).ToString());
-            dictValues.Add("Regrowth casts per minute", Math.Round(Sustained.spellMix.RegrowthCPM, 2).ToString());
-            dictValues.Add("Regrowth average up", Math.Round(Sustained.spellMix.RegrowthAvg, 2).ToString());
-            dictValues.Add("Lifebloom (stack) casts per minute", Math.Round(Sustained.spellMix.LifebloomStackCPM, 2).ToString());
-            dictValues.Add("Lifebloom (stack) average up", Math.Round(Sustained.spellMix.LifebloomStackAvg, 2).ToString());
-            dictValues.Add("Lifebloom (stack) method", LifebloomMethod_ToString(3, Sustained.rotSettings.lifeBloomType));
-            dictValues.Add("Lifebloom casts per minute", Math.Round(Sustained.spellMix.LifebloomCPM, 2).ToString());
-            dictValues.Add("Lifebloom average up", Math.Round(Sustained.spellMix.LifebloomAvg, 2).ToString());
-            dictValues.Add("Nourish casts per minute", Math.Round(Sustained.spellMix.NourishCPM, 2).ToString());
-            //dictValues.Add("Healing Touch casts per minute", Math.Round(, 2).ToString());
-            dictValues.Add("Swiftmend casts per minute", Math.Round(Sustained.spellMix.SwiftmendCPM, 2).ToString());
-            dictValues.Add("Wild Growth casts per minute", Math.Round(Sustained.spellMix.WildGrowthCPM, 2).ToString());
-            dictValues.Add("Revitalize procs per minute", Math.Round(Sustained.spellMix.RevitalizeProcsPerMinute, 2).ToString());
+		public double ComputeHastedCastTimeMS(int timeMS)
+		{
+			if (timeMS <= 1000)
+				return 1000.0;
+			if (timeMS == 1500)
+				return HastedInstantCastMS;
+			return computeHastedCastTimeMS(timeMS);
+		}
 
-//            dictValues.Add("RJ Heal per tick", Math.Round(Sustained.spellMix.rejuvenate.PeriodicTickwithCrit, 2).ToString()+"*"+Sustained.spellMix.rejuvenate.PeriodicTicks.ToString()+" ticks @ "+Sustained.spellMix.rejuvenate.PeriodicTickTime+" s");
-            dictValues.Add("RJ Heal per tick", Sustained.spellMix.rejuvenate.TickToString() );
-            dictValues.Add("RJ Tick time", Math.Round(Sustained.spellMix.rejuvenate.PeriodicTickTime, 2).ToString());
-            dictValues.Add("RJ HPS", Math.Round(Sustained.spellMix.rejuvenate.HPS, 2).ToString());
-            dictValues.Add("RJ HPM", Sustained.spellMix.rejuvenate.HPMToString());
-            dictValues.Add("RJ HPCT", Math.Round(Sustained.spellMix.rejuvenate.HPCT, 2).ToString());
+		double computeHastedCastTimeMS(int timeMS)
+		{
+			double hastedTimeMS = 0;
 
-            dictValues.Add("RG Heal", Sustained.spellMix.regrowth.ToString());
-            dictValues.Add("RG Tick", Sustained.spellMix.regrowth.TickToString());
-            dictValues.Add("RG HPS", Math.Round(Sustained.spellMix.regrowth.HPS, 2).ToString());
-            dictValues.Add("RG HPS (HoT only)", Math.Round(Sustained.spellMix.regrowth.HPS_HOT, 2).ToString());
-            dictValues.Add("RG HPM", Sustained.spellMix.regrowth.HPMToString());
-            dictValues.Add("RG HPCT", Math.Round(Sustained.spellMix.regrowth.HPCT, 2).ToString());
-            dictValues.Add("RG Heal (spam)", Sustained.spellMix.regrowthAgain.ToString());
-            dictValues.Add("RG HPS (spam)", Math.Round(Sustained.spellMix.regrowthAgain.HPCT_DH, 2).ToString());
-            dictValues.Add("RG HPM (spam)", Sustained.spellMix.regrowthAgain.HPMToString());
-            dictValues.Add("RG HPCT (spam)", Math.Round(Sustained.spellMix.regrowthAgain.HPCT_DH, 2).ToString());
+			int n = HasteProcUptimes.Length;
+			int maxmask = 1 << n;
+			for (int i = 0; i < maxmask; ++i)
+			{
+				int hasteRating = 0;
+				double hasteFactor = (1 + SpellHaste);
+				double fraction = 1.0;
+				for (int j = 0; j < n; ++j)
+				{
+					if ((i & (1 << j)) != 0)
+					{
+						hasteRating += HasteProcRatings[j];
+						hasteFactor *= HasteProcMultipliers[j];
+						fraction *= HasteProcUptimes[j];
+					}
+					else
+						fraction *= 1 - HasteProcUptimes[j];
+				}
 
-//            dictValues.Add("LB Tick", Math.Round(Sustained.spellMix.lifebloom.PeriodicTick, 2).ToString()+"*"+Sustained.spellMix.lifebloom.PeriodicTicks.ToString()+" ticks @ "+Sustained.spellMix.lifebloom.PeriodicTickTime+" s");
-            dictValues.Add("LB Tick", Sustained.spellMix.lifebloom.TickToString());
-            dictValues.Add("LB Bloom Heal", Math.Round(Sustained.spellMix.lifebloom.AverageHealingwithCrit, 2).ToString());
-            dictValues.Add("LB HPS", Math.Round(Sustained.spellMix.lifebloom.HPS, 2).ToString());
-            dictValues.Add("LB HPS (HoT only)", Math.Round(Sustained.spellMix.lifebloom.HPS_HOT, 2).ToString());
-            dictValues.Add("LB HPM", Sustained.spellMix.lifebloom.HPMToString());
-            dictValues.Add("LB HPCT", Math.Round(Sustained.spellMix.lifebloom.HPCT, 2).ToString());
+				double hasteRatingMult = 1.0f + StatConversion.GetSpellHasteFromRating((float)(HasteRating + hasteRating));
+				hasteFactor *= hasteRatingMult;
 
-            dictValues.Add("LBx2 (fast stack) HPS", Math.Round(Sustained.spellMix.lifebloomFast2Stack.HPS, 2).ToString());
-            dictValues.Add("LBx2 (fast stack) HPM", Sustained.spellMix.lifebloomFast2Stack.HPMToString());
-            dictValues.Add("LBx2 (fast stack) HPCT", Math.Round(Sustained.spellMix.lifebloomFast2Stack.HPCT, 2).ToString());
-            dictValues.Add("LBx3 (fast stack) HPS", Math.Round(Sustained.spellMix.lifebloomFastStack.HPS, 2).ToString());
-            dictValues.Add("LBx3 (fast stack) HPM", Math.Round(Sustained.spellMix.lifebloomFastStack.HPM, 2).ToString());
-            dictValues.Add("LBx3 (fast stack) HPCT", Math.Round(Sustained.spellMix.lifebloomFastStack.HPCT, 2).ToString());
-            dictValues.Add("LBx2 (slow stack) HPS", Math.Round(Sustained.spellMix.lifebloomSlow2Stack.HPS, 2).ToString());
-            dictValues.Add("LBx2 (slow stack) HPM", Sustained.spellMix.lifebloomSlow2Stack.HPMToString());
-            dictValues.Add("LBx2 (slow stack) HPCT", Math.Round(Sustained.spellMix.lifebloomSlow2Stack.HPCT, 2).ToString());
-            dictValues.Add("LBx3 (slow stack) HPS", Math.Round(Sustained.spellMix.lifebloomSlowStack.HPS, 2).ToString());
-            dictValues.Add("LBx3 (slow stack) HPM", Math.Round(Sustained.spellMix.lifebloomSlowStack.HPM, 2).ToString());
-            dictValues.Add("LBx3 (slow stack) HPCT", Math.Round(Sustained.spellMix.lifebloomSlowStack.HPCT, 2).ToString());
-            dictValues.Add("LBx3 (rolling) Tick", Sustained.spellMix.lifebloomRollingStack.TickToString());
-            dictValues.Add("LBx3 (rolling) HPS", Math.Round(Sustained.spellMix.lifebloomRollingStack.HPS, 2).ToString());
-            dictValues.Add("LBx3 (rolling) HPM", Sustained.spellMix.lifebloomRollingStack.HPMToString());
-            dictValues.Add("LBx3 (rolling) HPCT", Math.Round(Sustained.spellMix.lifebloomRollingStack.HPCT, 2).ToString());
+				hastedTimeMS += fraction * Math.Max(timeMS / hasteFactor, 1000);
+			}
+			return hastedTimeMS;
+		}
 
-            dictValues.Add("HT Heal", Sustained.spellMix.healingTouch.ToString());
-            dictValues.Add("HT HPS", Math.Round(Sustained.spellMix.healingTouch.HPCT_DH, 2).ToString());
-            dictValues.Add("HT HPM", Sustained.spellMix.healingTouch.HPMToString());
-            dictValues.Add("HT HPCT", Math.Round(Sustained.spellMix.healingTouch.HPCT_DH, 2).ToString());
+		public TreeStats(Character character, Stats stats, KeyValuePair<double, SpecialEffect>[] hasteProcs, double treeOfLifeUptime)
+		{
+			CalculationOptionsTree opts = character.CalculationOptions as CalculationOptionsTree;
 
-            dictValues.Add("WG first Tick", Sustained.spellMix.wildGrowth.TickToString());
-            dictValues.Add("WG HPS(single target)", Math.Round(Sustained.spellMix.wildGrowth.HPS / Sustained.spellMix.wildGrowth.MaxTargets, 2).ToString());
-            dictValues.Add("WG HPM(single target)", Math.Round(Sustained.spellMix.wildGrowth.HPM / Sustained.spellMix.wildGrowth.MaxTargets, 2).ToString());
-            dictValues.Add("WG HPS(max)", Sustained.spellMix.wildGrowth.HPSToString());
-            dictValues.Add("WG HPM(max)",Sustained.spellMix.wildGrowth.HPMToString());
+			Talents = character.DruidTalents;
+			Restoration = (opts != null) ? opts.Restoration : true;
 
-            dictValues.Add("N Heal",Sustained.spellMix.nourish[0].ToString());
-            dictValues.Add("N HPM", Sustained.spellMix.nourish[0].HPMToString());
-            dictValues.Add("N HPS", Math.Round(Sustained.spellMix.nourish[0].HPCT_DH, 2).ToString());
-            dictValues.Add("N HPCT", Math.Round(Sustained.spellMix.nourish[0].HPCT_DH, 2).ToString());
-            dictValues.Add("N (1 HoT) Heal", Sustained.spellMix.nourish[1].ToString());
-            dictValues.Add("N (1 HoT) HPM", Sustained.spellMix.nourish[1].HPMToString());
-            dictValues.Add("N (1 HoT) HPS", Math.Round(Sustained.spellMix.nourish[1].HPCT_DH, 2).ToString());
-            dictValues.Add("N (1 HoT) HPCT", Math.Round(Sustained.spellMix.nourish[1].HPCT_DH, 2).ToString());
-            //dictValues.Add("N (2 HoTs) Heal", Sustained.spellMix.nourish[2].ToString());
-            //dictValues.Add("N (2 HoTs) HPM", Math.Round(Sustained.spellMix.nourish[2].HPM_DH, 2).ToString());
-            //dictValues.Add("N (2 HoTs) HPS", Math.Round(Sustained.spellMix.nourish[2].HPCT_DH, 2).ToString());
-            //dictValues.Add("N (2 HoTs) HPCT", Math.Round(Sustained.spellMix.nourish[2].HPCT_DH, 2).ToString());
-            //dictValues.Add("N (3 HoTs) Heal", Sustained.spellMix.nourish[3].ToString());
-            //dictValues.Add("N (3 HoTs) HPM", Math.Round(Sustained.spellMix.nourish[3].HPM_DH, 2).ToString());
-            //dictValues.Add("N (3 HoTs) HPS", Math.Round(Sustained.spellMix.nourish[3].HPCT_DH, 2).ToString());
-            //dictValues.Add("N (3 HoTs) HPCT", Math.Round(Sustained.spellMix.nourish[3].HPCT_DH, 2).ToString());
-            //dictValues.Add("N (4 HoTs) Heal", Sustained.spellMix.nourish[4].ToString());
-            //dictValues.Add("N (4 HoTs) HPM", Math.Round(Sustained.spellMix.nourish[4].HPM_DH, 2).ToString());
-            //dictValues.Add("N (4 HoTs) HPS", Math.Round(Sustained.spellMix.nourish[4].HPCT_DH, 2).ToString());
-            //dictValues.Add("N (4 HoTs) HPCT", Math.Round(Sustained.spellMix.nourish[4].HPCT_DH, 2).ToString());
+			SpellHaste = stats.SpellHaste;
+			HasteRating = stats.HasteRating;
 
-            Swiftmend swift = new Swiftmend(LocalCharacter, CombatStats, new Rejuvenation(LocalCharacter, CombatStats));
-            dictValues.Add("SM Heal", swift.ToString());
-            dictValues.Add("SM HPM", swift.HPMToString());
-            dictValues.Add("SM Rejuv Lost Ticks", Math.Round(swift.rejuvTicksLost, 2).ToString());
-            Efflorescence efflorescence = new Efflorescence(LocalCharacter, BasicStats, new Rejuvenation(LocalCharacter, CombatStats));
-            dictValues.Add("Efflorescence Heal", efflorescence.TickToString());
-            
-            return dictValues;
-        }
-        public override float GetOptimizableCalculationValue(string calculation) {
-            switch (calculation) {
-                case "Mana": return CombatStats.Mana;
-                case "MP5": return Sustained.MPSInFSR;
-                case "Global CD": return (new Nourish(LocalCharacter, CombatStats)).gcd * 1000.0f;  // Use Nourish gcd to equal normal GCD
-            }
-            return 0f;
-        }
-    }
+			HasteProcUptimes = new double[hasteProcs.Length];
+			HasteProcRatings = new int[hasteProcs.Length];
+			HasteProcMultipliers = new double[hasteProcs.Length];
+
+			for(int i = 0; i < hasteProcs.Length; ++i)
+			{
+				HasteProcUptimes[i] = hasteProcs[i].Key;
+				HasteProcRatings[i] = (int)hasteProcs[i].Value.Stats.HasteRating;
+				HasteProcMultipliers[i] = 1 + hasteProcs[i].Value.Stats.SpellHaste;
+			}
+
+			SpellCrit = StatConversion.GetSpellCritFromIntellect(stats.Intellect) + StatConversion.GetSpellCritFromRating(stats.CritRating) + stats.SpellCrit;
+
+			SpellPower = (float)(stats.SpellPower + Math.Max(0f, stats.Intellect - 10));
+			// TODO: does nurturing instinct actually work like this?
+			SpellPower += character.DruidTalents.NurturingInstinct * 0.5 * stats.Agility;
+			SpellPower *= (1 + stats.BonusSpellPowerMultiplier);
+
+			TreeOfLifeUptime = treeOfLifeUptime;
+			double mastery = 8.0f + StatConversion.GetMasteryFromRating(stats.MasteryRating);
+			if(Restoration)
+			{
+				if(!opts.Harmony)
+					Symbiosis = mastery * 0.0145f;
+				else
+					Harmony = mastery * opts.HarmonyCoefficient;
+			}
+
+			SpellsManaCostReduction = stats.SpellsManaCostReduction + stats.NatureSpellsManaCostReduction;
+			BonusCritHealMultiplier = stats.BonusCritHealMultiplier;
+
+			HastedSecond = computeHastedCastTimeMS(1 << 16) / 65536.0;
+			HastedInstantCastMS = computeHastedCastTimeMS(1500);
+		}
+	}
+
+
+	public class CharacterCalculationsTree : CharacterCalculationsBase
+	{
+		private float[] subPoints = new float[(int)PointsTree.Count];
+		public override float[] SubPoints
+		{
+			get { return subPoints; }
+			set { subPoints = value; }
+		}
+		public override float OverallPoints { get; set; }
+
+		public TreeStats MeanStats { get; set; }
+		public double MeanMana { get; set; }
+		public double InnervateMana { get; set; }
+
+		public double ManaRegen { get; set; }
+		public double BaseRegen { get; set; }
+		public double ManaPoolRegen { get; set; }
+		public double PotionRegen { get; set; }
+		public double SpiritRegen { get; set; }
+		public double InnervateRegen { get; set; }
+		public double ExternalInnervateRegen { get; set; }
+		public double ReplenishmentRegen { get; set; }
+		public double RevitalizeRegen { get; set; }
+
+		public double FightLength { get; set; }
+		public double Innervates { get; set; }
+		
+		private Stats baseStats;
+		public Stats BasicStats { get { return baseStats; } set { baseStats = value; } }
+
+		public Action[] Actions { get; set; }
+		public ActionDistribution[] Distributions { get; set; }
+
+		public SpecialEffect[] FriendlyOnUseEffects { get; set; }
+		public double[] DivisionFractions { get; set; }
+		public int[] DivisionEffectMasks { get; set; }
+		public TreeStats[] DivisionStats { get; set; }
+		public Action[][] DivisionActions { get; set; }
+		public ActionDistribution[][] DivisionDistributions { get; set; }
+
+		delegate string DivisionTextDelegate(int divment);
+
+		String getDivisionDetailTooltip(DivisionTextDelegate del)
+		{
+			StringBuilder sb = new StringBuilder();
+			for (int i = 0; i < FriendlyOnUseEffects.Length; ++i)
+			{
+				sb.Append(char.ConvertFromUtf32(char.ConvertToUtf32("A", 0) + i));
+				sb.Append(" = ");
+				sb.AppendLine(FriendlyOnUseEffects[i].ToString());
+			}
+			sb.AppendLine();
+
+			for (int i = 0; i < DivisionEffectMasks.Length; ++i)
+			{
+				for(int j = 0; j < FriendlyOnUseEffects.Length; ++j)
+				{
+					if((DivisionEffectMasks[i] & (1 << j)) != 0)
+						sb.Append(char.ConvertFromUtf32(char.ConvertToUtf32("A", 0) + j));
+				}
+				sb.Append(": ");
+				sb.AppendLine(del(i));
+			}
+			return sb.ToString();
+		}
+
+		public override Dictionary<string, string> GetCharacterDisplayCalculationValues()
+		{
+			Dictionary<string, string> retVal = new Dictionary<string, string>();
+			//
+			if (baseStats == null) baseStats = new Stats();
+
+			retVal.Add("Health", baseStats.Health.ToString());
+			retVal.Add("Mana", baseStats.Mana.ToString());
+			retVal.Add("Mean Mana", String.Format("{0:F0}", MeanMana));
+			retVal.Add("Innervate Mana", String.Format("{0:F0}", InnervateMana));
+			retVal.Add("Armor", baseStats.Armor.ToString());
+			retVal.Add("Agility", baseStats.Agility.ToString());
+			retVal.Add("Stamina", baseStats.Stamina.ToString());
+			retVal.Add("Intellect", String.Format("{0:F0}", baseStats.Intellect));
+			retVal.Add("Spirit", baseStats.Spirit.ToString());
+			retVal.Add("Spell Power", String.Format("{0:F0}", MeanStats.SpellPower));
+			retVal.Add("Spell Crit", String.Format("{0:F}%*{1} Crit Rating from Gear, {2:F}% Crit from Gear, {3:F}% Crit from Gear Intellect",
+			    100 * MeanStats.SpellCrit,
+			    baseStats.CritRating,
+			    100 * StatConversion.GetSpellCritFromRating(baseStats.CritRating),
+			    100 * StatConversion.GetSpellCritFromIntellect(baseStats.Intellect)));
+			retVal.Add("Spell Haste", String.Format("{0:F}%*{1} Haste Rating, {2:F}% Haste from Gear, {3:F}% Haste from Gear and Buffs",
+			    100 * (1 / MeanStats.HastedSecond - 1),
+			    (float)baseStats.HasteRating,
+			    100 * StatConversion.GetSpellHasteFromRating((float)baseStats.HasteRating),
+			    100 * ((1 + StatConversion.GetSpellHasteFromRating((float)baseStats.HasteRating)) * (1.0f + baseStats.SpellHaste) - 1)
+			    ));
+			retVal.Add("Spell Mana Cost Reduction", MeanStats.SpellsManaCostReduction.ToString());
+			retVal.Add("Spell Crit Extra Bonus", String.Format("{0:F}%", 100 * MeanStats.BonusCritHealMultiplier));
+			retVal.Add("Symbiosis", String.Format("{0:F}%*{1} Mastery Rating from Gear",
+			    MeanStats.Symbiosis * 100,
+			    baseStats.MasteryRating));
+			retVal.Add("Harmony", String.Format("{0:F}%*{1} Mastery Rating from Gear",
+			    MeanStats.Harmony * 100,
+			    baseStats.MasteryRating));
+			retVal.Add("Mana Regen", String.Format("{0:F0}", ManaRegen));
+			retVal.Add("Base Mana Regen", String.Format("{0:F0}", BaseRegen));
+			retVal.Add("Initial Mana Pool Regen", String.Format("{0:F0}", ManaPoolRegen));
+			retVal.Add("Spirit Mana Regen", String.Format("{0:F0}", SpiritRegen));
+			retVal.Add("Innervate Mana Regen", String.Format("{0:F0}", InnervateRegen));
+			retVal.Add("Ext Innervate Mana Regen", String.Format("{0:F0}", ExternalInnervateRegen));
+			retVal.Add("Replenishment Mana Regen", String.Format("{0:F0}", ReplenishmentRegen));
+			retVal.Add("Revitalize Mana Regen", String.Format("{0:F0}", RevitalizeRegen));
+			retVal.Add("Potion Mana Regen", String.Format("{0:F0}", PotionRegen));
+			retVal.Add("Innervates", Innervates.ToString());
+
+			retVal.Add("Fight Length", String.Format("{0:F0}s", FightLength));
+			retVal.Add("Divisions", DivisionFractions.Length.ToString() + "*" + getDivisionDetailTooltip(i => String.Format("{0:F0}s ({1:F2}%)", DivisionFractions[i] * FightLength, 100 * DivisionFractions[i])));
+
+			retVal.Add("Total Score", String.Format("{0:F2}", OverallPoints));
+			retVal.Add("Raid Sustained HPS", String.Format("{0:F2}", Distributions[(int)PointsTree.RaidSustained].TotalEPS));
+			retVal.Add("Raid Burst HPS", String.Format("{0:F2}", Distributions[(int)PointsTree.RaidBurst].TotalEPS));
+			retVal.Add("Tank Sustained HPS", String.Format("{0:F2}", Distributions[(int)PointsTree.TankSustained].TotalEPS));
+			retVal.Add("Tank Burst HPS", String.Format("{0:F2}", Distributions[(int)PointsTree.TankBurst].TotalEPS));
+
+			for (int i = 0; i < Actions.Length; ++i)
+			{
+				/*
+				KeyValuePair<string, float>[] values = Actions[i].GetValues(true);
+				foreach(KeyValuePair<string, float> pair in values)
+				{
+					retVal.Add(Actions[i].Name + " " + pair.Key, String.Format((pair.Value < 100) ? "{0:F2}" : "{0:F0}", pair.Value));
+				}
+				*/
+				KeyValuePair<string, string>[] values = Actions[i].GetSuccinctValues(true);
+				foreach(KeyValuePair<string, string> pair in values)
+				{
+					retVal.Add(Action.GetName((TreeAction)i) + " " + pair.Key, pair.Value + "*" + getDivisionDetailTooltip(div => DivisionActions[div][i].GetSuccinctValues(true).Find(x => x.Key == pair.Key).Value) ?? "");
+				}
+			}
+
+			string[] names = {"Raid S.", "Raid B.", "Tank S.", "Tank B."};
+			for (int i = 0; i < Distributions.Length; ++i)
+			{
+				for (int j = 0; j < Actions.Length; ++j)
+				{
+					if (Distributions[i].EPS[j] > 0)
+						retVal.Add(names[i] + ' ' + Action.GetName((TreeAction)j), String.Format("{0:F0} = {1:F1}% ({2:F1}t, {3:F0}m)", Distributions[i].EPS[j], Distributions[i].EPS[j] / Distributions[i].TotalEPS * 100.0f, Distributions[i].Fraction[j] * 100.0f, Distributions[i].MPS[j])
+							+ "*" + getDivisionDetailTooltip(div => String.Format("{0:F0} = {1:F1}% ({2:F1}t, {3:F0}m)", DivisionDistributions[i][div].EPS[j], DivisionDistributions[i][div].EPS[j] / DivisionDistributions[i][div].TotalEPS * 100.0f, DivisionDistributions[i][div].Fraction[j] * 100.0f, DivisionDistributions[i][div].MPS[j]))
+							);
+					else
+						retVal.Add(names[i] + ' ' + Action.GetName((TreeAction)j), "");
+				}
+				retVal.Add(names[i] + " Idle", String.Format("{0:F0}%, {1:F0}m", (1 - Distributions[i].TotalFraction) * 100.0f, ManaRegen - Distributions[i].TotalMPS)
+					+ "*" + getDivisionDetailTooltip(div => String.Format("{0:F0}%, {1:F0}m", (DivisionDistributions[i][div].MaxFraction - DivisionDistributions[i][div].TotalFraction) * 100.0f, DivisionDistributions[i][div].MaxMPS - DivisionDistributions[i][div].TotalMPS))
+					);
+			}
+			return retVal;
+		}
+
+		public override float GetOptimizableCalculationValue(string calculation)
+		{
+			switch (calculation)
+			{
+				case "Spirit": return baseStats.Spirit;
+				case "Haste Rating": return baseStats.HasteRating;
+				case "Crit Rating": return baseStats.CritRating;
+				case "Mastery Rating": return baseStats.MasteryRating;
+			}
+			return 0;
+		}
+	}
 }
Index: Rawr.Tree/ComparisonCalculationTree.cs
===================================================================
--- Rawr.Tree/ComparisonCalculationTree.cs	(revision 60557)
+++ Rawr.Tree/ComparisonCalculationTree.cs	(working copy)
@@ -14,31 +14,13 @@
 
         public override float OverallPoints { get; set; }
 
-        private float[] subPoints = new float[] { 0f, 0f, 0f };
+        private float[] subPoints = new float[] { 0f, 0f, 0f, 0f, 0f };
         public override float[] SubPoints
         {
             get { return subPoints; }
             set { subPoints = value; }
         }
 
-        public float BurstPoints
-        {
-            get { return subPoints[0]; }
-            set { subPoints[0] = value; }
-        }
-
-        public float SustainedPoints
-        {
-            get { return (subPoints.Length>1)?subPoints[1]: 0; }
-            set { subPoints[1] = value; }
-        }
-
-        public float SurvivalPoints
-        {
-            get { return (subPoints.Length>2)?subPoints[2]: 0; }
-            set { subPoints[2] = value; }
-        } 
-
         private Item _item = null;
         public override Item Item 
         {
@@ -61,7 +43,7 @@
             if (subPoints.Length == 1)
                 return string.Format("{0}: ({1:0.0}O )", Name, OverallPoints);
             else
-                return string.Format("{0}: ({1:0.0}O {2:0.0}H {3:0.0}M {4:0.0}S )", Name, OverallPoints, BurstPoints, SustainedPoints, SurvivalPoints);
+		return string.Format("{0}: (Tank ({1:0.0} -> {2:0.0}) Raid ({3:0.0} -> {4:0.0}))", Name, OverallPoints, SubPoints[(int)PointsTree.TankSustained], SubPoints[(int)PointsTree.TankBurst], SubPoints[(int)PointsTree.RaidSustained], SubPoints[(int)PointsTree.RaidBurst]);
         }
     }
 }
Index: Rawr.Tree/TreeSolver.cs
===================================================================
--- Rawr.Tree/TreeSolver.cs	(revision 0)
+++ Rawr.Tree/TreeSolver.cs	(revision 0)
@@ -0,0 +1,811 @@
+ï»¿using System;
+using System.Collections.Generic;
+
+namespace Rawr.Tree
+{
+	public class SpellData
+	{
+		public string Name;
+		public int BaseManaPercent;
+		public int TimeMS;
+		public int MinHeal;
+		public int MaxHeal;
+		public int Coeff;
+		public int TickHeal;
+		public int TickCoeff;
+
+		public double ExtraDirectBonus;
+		public double ExtraTickBonus;
+		public double ExtraDirectMult;
+		public double ExtraDirectCrit;
+		public double ExtraTickCrit;
+		public double ExtraCritBonus;
+		public double InstantTicks;
+
+		public SpellData(string name, int baseManaPercent, int timeMS, int minHeal, int maxHeal, int coeff, int tickHeal = 0, int tickCoeff = 0)
+		{
+			this.Name = name;
+			this.BaseManaPercent = baseManaPercent;
+			this.TimeMS = timeMS;
+			this.MinHeal = minHeal;
+			this.MaxHeal = maxHeal;
+			this.Coeff = coeff;
+			this.TickHeal = tickHeal;
+			this.TickCoeff = tickCoeff;
+		}
+	}
+
+	public class TreeSolver
+	{
+		Character character;
+		CharacterCalculationsTree calc;
+		CalculationOptionsTree opts;
+		int BaseMana;
+
+		class TreeComputedData
+		{
+			public double LifebloomDuration;
+			public double LifebloomTicks;
+			public double LifebloomTPS;
+
+			public double RejuvenationDuration;
+		}
+
+		TreeComputedData[] DivisionData;
+
+		public TreeSolver(Character character, CharacterCalculationsTree calc)
+		{
+			this.character = character;
+			this.calc = calc;
+			this.opts = (CalculationOptionsTree)character.CalculationOptions;
+			if (opts == null)
+				opts = new CalculationOptionsTree();
+			
+			BaseMana = (int)BaseStats.GetBaseStats(character).Mana;
+
+			compute();
+		}
+
+		void compute()
+		{
+			List<KeyValuePair<double, double>> randomIntellectProcsMana = new List<KeyValuePair<double, double>>();
+			randomIntellectProcsMana.Add(new KeyValuePair<double, double>(0, 0));
+			double onUseIntellectProcsMana = 0.0f;
+
+			calc.MeanMana = calc.BasicStats.Mana;
+
+			List<KeyValuePair<double, SpecialEffect>> hasteProcsList = new List<KeyValuePair<double, SpecialEffect>>();
+
+			// ToL, NG, Heroism, Shard of Woe
+			List<SpecialEffect> friendlyOnUseEffectsList = new List<SpecialEffect>();
+
+			KeyValuePair<double, SpecialEffect>[] hasteProcs;
+			Stats statsMean = new Stats();
+			Stats statsProcs = new Stats();
+			foreach (SpecialEffect effect in calc.BasicStats.SpecialEffects())
+			{
+				float triggerInterval = 0.0f, triggerChance = 1.0f;
+				if (CalculationsTree.RelevantTriggers.Contains(effect.Trigger))
+				{
+					if (effect.Trigger != Trigger.Use)
+						triggerInterval = 0.5f;
+					if (effect.Stats.Intellect > 0)
+					{
+						double mana = StatConversion.GetManaFromIntellect(effect.Stats.Intellect * (1 + calc.BasicStats.BonusIntellectMultiplier)) * (1 + calc.BasicStats.BonusManaMultiplier);
+						double avgMana = mana * effect.GetAverageFactor(triggerInterval, triggerChance, 3.0f, character.BossOptions.BerserkTimer);
+						if (opts.TimedInnervates)
+						{
+							if (effect.Trigger != Trigger.Use && effect.Cooldown <= 60.0f)
+							{
+								double delay = 1.0 / effect.GetAverageProcsPerSecond(triggerInterval, triggerChance, 3.0f, character.BossOptions.BerserkTimer);
+								randomIntellectProcsMana.Add(new KeyValuePair<double, double>(delay, mana - avgMana));
+							}
+							if (effect.Trigger == Trigger.Use && effect.Cooldown <= 180.0f)
+								onUseIntellectProcsMana += mana - avgMana;
+						}
+						calc.MeanMana += avgMana;
+					}
+
+					Stats stats = effect.GetAverageStats(triggerInterval, triggerChance, 3.0f, character.BossOptions.BerserkTimer);
+					// restrict us to things that can be easily aligned with minute-long cooldowns, for now (which happens to be everything in tier 11)
+					if (effect.Trigger == Trigger.Use
+						&& effect.MaxStack <= 1 && effect.Duration <= 60.0f
+						&& (effect.Cooldown >= 480.0f || (effect.Cooldown == 60.0f * Math.Floor(effect.Cooldown / 60.0f)))
+						&& (effect.Stats is CalculationsTree.TreeOfLifeStats || effect.Stats.HasteRating > 0 || effect.Stats.SpellHaste > 0 || effect.Stats.Intellect > 0 || effect.Stats.SpellPower > 0 || effect.Stats.CritRating > 0 || effect.Stats.SpellCrit > 0 || effect.Stats.MasteryRating > 0)
+						)
+						friendlyOnUseEffectsList.Add(effect);
+					else
+					{
+						if (effect.Stats.HasteRating > 0 || effect.Stats.SpellHaste > 0)
+						{
+							double uptime = effect.GetAverageUptime(triggerInterval, triggerChance, 3.0f, character.BossOptions.BerserkTimer);
+							hasteProcsList.Add(new KeyValuePair<double, SpecialEffect>(uptime, effect));
+							stats.HasteRating = 0;
+							stats.SpellHaste = 0;
+						}
+						statsProcs.Accumulate(stats);
+					}
+
+					statsMean.Accumulate(stats);
+				}
+			}
+			// XXX: this fixes Tyrande's Favorite Doll, but seems to be a bug in Rawr
+			statsMean.Mp5 = statsMean.ManaRestore * 5;
+			statsMean.ManaRestore = 0;
+
+			statsMean.Intellect *= (1 + calc.BasicStats.BonusIntellectMultiplier);
+			statsMean.Agility *= (1 + calc.BasicStats.BonusAgilityMultiplier);
+			statsMean.Spirit *= (1 + calc.BasicStats.BonusSpiritMultiplier);
+
+			statsMean.Accumulate(calc.BasicStats);
+
+			hasteProcs = hasteProcsList.ToArray();
+			calc.FriendlyOnUseEffects = friendlyOnUseEffectsList.ToArray();
+			Array.Sort(calc.FriendlyOnUseEffects, ((a, b) => (a.Cooldown == b.Cooldown) ? Math.Sign(a.Duration - b.Duration) : Math.Sign(b.Cooldown - a.Cooldown)));
+
+			BossOptions bossOpts = character.BossOptions;
+			calc.FightLength = bossOpts.BerserkTimer;
+
+			double innervateGains = 0;
+			double innervateFightLength = calc.FightLength * 0.8; // for 20% of the fight we'll have less than 20% mana missing
+			double innervateRatio;
+			double innervateCooldown = 180;
+			calc.InnervateMana = 0;
+			calc.Innervates = 0;
+
+			int numExternalInnervates = innervateFightLength > 0 ? ((int)(innervateFightLength / innervateCooldown) + 1) : 0;
+			if (opts.InnervateOther)
+			{
+				if (character.DruidTalents.GlyphOfInnervate)
+					innervateRatio = 0.1;
+				else
+					innervateRatio = 0;
+			}
+			else
+				innervateRatio = 0.2 + character.DruidTalents.Dreamstate * 0.15;
+
+			if (innervateRatio > 0 && innervateFightLength > 0)
+			{
+				foreach (KeyValuePair<double, double> proc in randomIntellectProcsMana)
+				{
+					int numInnervates = (int)(innervateFightLength / (innervateCooldown + proc.Key)) + 1;
+					double curInnervateMana = calc.MeanMana + onUseIntellectProcsMana + proc.Value;
+					double curInnervateGains = curInnervateMana * 0.2 * numInnervates;
+					if (curInnervateGains > innervateGains)
+					{
+						calc.InnervateMana = curInnervateMana;
+						calc.Innervates = numInnervates;
+						innervateGains = curInnervateGains;
+					}
+				}
+			}
+
+			double revitalizeDelay = 1.0f;
+			calc.ManaPoolRegen = calc.BasicStats.Mana / calc.FightLength;
+			calc.BaseRegen = statsMean.Mp5 / 5f;
+			calc.SpiritRegen = opts.Restoration ? (StatConversion.GetSpiritRegenSec(statsMean.Spirit, statsMean.Intellect) / 2) : 0;
+			calc.ReplenishmentRegen = statsMean.ManaRestoreFromMaxManaPerSecond * calc.MeanMana;
+			calc.InnervateRegen = innervateGains / calc.FightLength;
+			calc.ExternalInnervateRegen = opts.ExternalInnervateSize * numExternalInnervates;
+			calc.RevitalizeRegen = character.DruidTalents.Revitalize * (1.0f / (12.0f + revitalizeDelay)) * 0.01f * calc.MeanMana;
+			calc.PotionRegen = statsMean.ManaRestore / calc.FightLength;
+
+			calc.ManaRegen = calc.ManaPoolRegen + calc.BaseRegen + calc.SpiritRegen + calc.ReplenishmentRegen + calc.InnervateRegen + calc.ExternalInnervateRegen + calc.RevitalizeRegen + calc.PotionRegen;
+
+			// 1 = ToL, 2 = NG, 4 = Heroism, 8 = Shard of Woe, 16 = SoW _then_ NG
+			List<double> divisionFractionsList = new List<double>();
+			List<int> divisionEffectMasksList = new List<int>();
+			{
+				int n = calc.FriendlyOnUseEffects.Length;
+				int[] occurrences = new int[n];
+				double[] durations = new double[n];
+				bool[] isHasteEffect = new bool[n];
+				for (int i = 0; i < n; ++i)
+				{
+					occurrences[i] = (int)Math.Ceiling(calc.FightLength / calc.FriendlyOnUseEffects[i].Cooldown);
+					durations[i] = calc.FriendlyOnUseEffects[i].Duration;
+					isHasteEffect[i] = opts.SeparateHasteEffects && calc.FriendlyOnUseEffects[i].Cooldown <= 60.0f
+						&& (calc.FriendlyOnUseEffects[i].Stats.HasteRating > 0 || calc.FriendlyOnUseEffects[i].Stats.SpellHaste > 0);
+				}
+
+				double[] durationsLeft = new double[n];
+
+				double totalFraction = 0;
+				for (; ; )
+				{
+					int curOccurrences = int.MaxValue;
+					List<int> effectsList = new List<int>();
+					for (int i = 0; i < n; ++i)
+						durationsLeft[i] = 0;
+					for (int i = 0; i < n; ++i)
+					{
+						if (occurrences[i] > 0)
+						{
+							curOccurrences = Math.Min(curOccurrences, occurrences[i]);
+							durationsLeft[i] = durations[i];
+						}
+					}
+					if (curOccurrences == int.MaxValue)
+						break;
+
+					for (int i = 0; i < n; ++i)
+						occurrences[i] -= curOccurrences;
+
+					for (; ; )
+					{
+						double curDuration = double.PositiveInfinity;
+						int mask = 0;
+						bool haveHasteEffect = false;
+						for (int i = 0; i < n; ++i)
+						{
+							if (durationsLeft[i] > 0)
+							{
+								if (isHasteEffect[i])
+								{
+									if (haveHasteEffect)
+										continue;
+									haveHasteEffect = true;
+								}
+								curDuration = Math.Min(curDuration, durationsLeft[i]);
+								mask |= (1 << i);
+							}
+						}
+
+						if (double.IsPositiveInfinity(curDuration))
+							break;
+
+						for (int i = 0; i < n; ++i)
+						{
+							if ((mask & (1 << i)) != 0)
+								durationsLeft[i] -= curDuration;
+						}
+
+						double fraction = curOccurrences * curDuration / calc.FightLength;
+						totalFraction += fraction;
+						divisionFractionsList.Add(fraction);
+						divisionEffectMasksList.Add(mask);
+					}
+				}
+				divisionFractionsList.Add(1 - totalFraction);
+				divisionEffectMasksList.Add(0);
+			}
+			calc.DivisionFractions = divisionFractionsList.ToArray();
+			calc.DivisionEffectMasks = divisionEffectMasksList.ToArray();
+
+			calc.MeanStats = new TreeStats(character, statsMean, hasteProcs, (character.DruidTalents.MasterShapeshifter > 0) ? CalculationsTree.TreeOfLife[character.DruidTalents.MasterShapeshifter].GetAverageUptime(0, 1) : 0);
+
+			calc.DivisionActions = new Action[calc.DivisionFractions.Length][];
+			calc.DivisionStats = new TreeStats[calc.DivisionFractions.Length];
+			DivisionData = new TreeComputedData[calc.DivisionFractions.Length];
+
+			for (int div = 0; div < calc.DivisionFractions.Length; ++div)
+			{
+				Stats statsWithOnUse = new Stats();
+				bool treeOfLifeActive = false;
+				for (int j = 0; j < calc.FriendlyOnUseEffects.Length; ++j)
+				{
+					if ((calc.DivisionEffectMasks[div] & (1 << j)) != 0)
+					{
+						statsWithOnUse.Accumulate(calc.FriendlyOnUseEffects[j].Stats);
+						if (calc.FriendlyOnUseEffects[j].Stats is CalculationsTree.TreeOfLifeStats)
+							treeOfLifeActive = true;
+					}
+				}
+
+				statsWithOnUse.Accumulate(statsProcs);
+
+				// XXX: this fixes Tyrande's Favorite Doll, but seems to be a bug in Rawr
+				statsWithOnUse.Mp5 = statsMean.ManaRestore * 5;
+				statsWithOnUse.ManaRestore = 0;
+
+				statsWithOnUse.Intellect *= (1 + calc.BasicStats.BonusIntellectMultiplier);
+				statsWithOnUse.Agility *= (1 + calc.BasicStats.BonusAgilityMultiplier);
+				statsWithOnUse.Spirit *= (1 + calc.BasicStats.BonusSpiritMultiplier);
+
+				statsWithOnUse.Accumulate(calc.BasicStats);
+
+				calc.DivisionStats[div] = new TreeStats(character, statsWithOnUse, hasteProcs, treeOfLifeActive ? 1.0 : 0.0);
+				calc.DivisionActions[div] = buildActions(calc.DivisionStats[div], out DivisionData[div]);
+			}
+
+			calc.Actions = new Action[calc.DivisionActions[0].Length];
+			for (int j = 0; j < calc.Actions.Length; ++j)
+				calc.Actions[j] = new Action();
+
+			{
+				double[] totalFraction = new double[calc.Actions.Length];
+				for (int i = 0; i < calc.DivisionFractions.Length; ++i)
+				{
+					for (int j = 0; j < calc.Actions.Length; ++j)
+					{
+						if (calc.DivisionActions[i][j].Time > 0)
+						{
+							totalFraction[j] += calc.DivisionFractions[i];
+							calc.Actions[j].OverTimePS += calc.DivisionFractions[i] * calc.DivisionActions[i][j].OverTimePS;
+							calc.Actions[j].DirectPS += calc.DivisionFractions[i] * calc.DivisionActions[i][j].DirectPS;
+							calc.Actions[j].MPS += calc.DivisionFractions[i] * calc.DivisionActions[i][j].MPS;
+							calc.Actions[j].Time += calc.DivisionFractions[i] * calc.DivisionActions[i][j].Time;
+						}
+					}
+				}
+
+				for (int j = 0; j < calc.Actions.Length; ++j)
+				{
+					if (totalFraction[j] > 0)
+					{
+						calc.Actions[j].OverTimePS /= totalFraction[j];
+						calc.Actions[j].DirectPS /= totalFraction[j];
+						calc.Actions[j].MPS /= totalFraction[j];
+						calc.Actions[j].Time /= totalFraction[j];
+					}
+				}
+			}
+
+			calc.DivisionDistributions = new ActionDistribution[(int)PointsTree.Count][];
+			calc.Distributions = new ActionDistribution[(int)PointsTree.Count];
+
+			for(int model = 0; model < 4; ++model)
+			{
+				int[] fillers;
+				bool isTank = (model >> 1) == 1;
+				bool infMana = (model & 1) == 1;
+				ActionDistribution[] dists = isTank ? computeTankHealing(infMana, out fillers) : computeRaidHealing(infMana, out fillers);
+				
+				/*
+				for (int submodel = 0; submodel < 2; ++submodel)
+				{
+					ActionDistribution[] dists = new ActionDistribution[baseDists.Length];
+					for (int i = 0; i < baseDists.Length; ++i)
+						dists[i] = (ActionDistribution)baseDists[i].Clone();
+					if (submodel == 1)
+						ActionOptimization.AddBestActions(dists, calc.DivisionFractions, fillers);
+					else
+					{
+						for (int i = 0; i < dists.Length; ++i)
+							dists[i].AddBestActions(fillers);
+					}
+
+					int modelid = model * 2 + submodel;
+				}
+				*/
+
+				ActionOptimization.AddBestActions(dists, calc.DivisionFractions, fillers, isTank ? opts.TankUnevenlyAllocatedFillerMana : opts.RaidUnevenlyAllocatedFillerMana);
+				calc.DivisionDistributions[model] = dists;
+				calc.Distributions[model] = ActionDistribution.Combine(dists, calc.DivisionFractions);
+			}
+			
+
+			
+			calc.SubPoints[(int)PointsTree.RaidSustained] = (float)(calc.Distributions[(int)PointsTree.RaidSustained].TotalEPS * (1 - opts.TankRatio) * (1 - opts.RaidBurstRatio));
+			calc.SubPoints[(int)PointsTree.RaidBurst] = (float)(calc.Distributions[(int)PointsTree.RaidBurst].TotalEPS * (1 - opts.TankRatio) * opts.RaidBurstRatio);
+			calc.SubPoints[(int)PointsTree.TankSustained] = (float)(calc.Distributions[(int)PointsTree.TankSustained].TotalEPS * opts.TankRatio * (1 - opts.TankBurstRatio));
+			calc.SubPoints[(int)PointsTree.TankBurst] = (float)(calc.Distributions[(int)PointsTree.TankBurst].TotalEPS * opts.TankRatio * opts.TankBurstRatio);
+
+			calc.OverallPoints = 0;
+			for (int i = 0; i < (int)PointsTree.Count; ++i)
+				calc.OverallPoints += calc.SubPoints[i];
+		}
+
+		Action computeSpell(TreeStats stats, SpellData spell)
+		{
+			Action action = new Action();
+			
+			double passiveHealBonus = stats.Restoration ? 0.25f : 0.0f;
+
+			double healmult = 1.0f + stats.Talents.MasterShapeshifter * 0.04f;
+
+			action.Time = stats.ComputeHastedCastTimeMS(spell.TimeMS) / 1000.0;
+
+			action.DirectPS = 0;
+			if(spell.MaxHeal > 0 || spell.Coeff > 0)
+			{
+				double direct = (double)(spell.MinHeal + spell.MaxHeal) / 2.0f + stats.SpellPower * (double)spell.Coeff / 10000.0f;
+				direct *= (1.0f + passiveHealBonus + spell.ExtraDirectBonus) * (1.0f + spell.ExtraDirectMult) * healmult;
+				double directCrit = stats.SpellCrit + spell.ExtraDirectCrit;
+				direct *= (directCrit * ((opts.Crit100Bonus ? 2.0 : 1.5) + stats.BonusCritHealMultiplier) * (1 + spell.ExtraCritBonus) + (1 - directCrit));
+				action.Direct = direct * (1 + stats.Harmony);
+			}
+
+			action.OverTimePS = 0;
+			if(spell.TickHeal > 0 || spell.TickCoeff > 0)
+			{
+				double tick = spell.TickHeal + stats.SpellPower * spell.TickCoeff / 10000.0f;
+				tick *= (1.0f + passiveHealBonus + 0.02f * stats.Talents.Genesis + spell.ExtraTickBonus) * healmult;
+				
+				action.Direct += spell.InstantTicks * tick;
+
+				double tickCrit = stats.SpellCrit + spell.ExtraTickCrit;
+				tick *= (tickCrit * ((opts.Crit100Bonus ? 2.0 : 1.5) + stats.BonusCritHealMultiplier) * (1 + spell.ExtraCritBonus) + (1 - tickCrit));
+
+				action.OverTime = tick * (1 + stats.Harmony);
+			}
+			
+			double mana = Math.Floor(BaseMana * spell.BaseManaPercent / 100f);
+			mana -= stats.SpellsManaCostReduction;
+			mana *= 1.0f - stats.Talents.Moonglow * 0.03f;
+			mana = (double)Math.Floor(mana);
+			action.Mana = (int)mana;
+
+			return action;
+		}
+
+		Action applySymbiosis(Action action, double symbiosis, double symbiosisRate, bool isNourish = false)
+		{
+			Action a = (Action)action.Clone();
+			double healmult = (symbiosisRate * (1.0f + symbiosis) * (isNourish ? 1.2f : 1.0f) + (1 - symbiosisRate));
+			a.DirectPS *= healmult;
+			a.OverTimePS *= healmult;
+			return a;
+		}
+
+		Action applyCC(Action action)
+		{
+			Action a = (Action)action.Clone();
+			a.MPS = 0;
+			return a;
+		}
+
+		// cast Rejuvenation rjn times to get Nature's Bounty, then cast Nourish until it drops off
+		// TODO: do we have some extra time before it drops off?
+		Action buildNourishNB(TreeStats stats, Action rj, double rjduration, int rjn, bool rjHeals, Action nourish)
+		{
+			Action action = new Action();
+			double nourishTime = (rjduration - rj.Time * rjn) / (1.0f - 0.1f * stats.Talents.NaturesBounty);
+			action.Time = rjduration;
+			action.OverTime = (rjHeals ? (rj.OverTime * rjn) : 0);
+			action.Direct = (rjHeals ? (rj.Direct * rjn) : 0) + nourishTime * nourish.DirectPS;
+			action.Mana = rj.Mana * rjn + nourishTime * nourish.MPS;
+			return action;
+		}
+
+		Action buildTolLbCcHt(TreeStats stats, TreeComputedData data, Action tollb, bool tollbHeals, Action ccht)
+		{
+			double cchtsPerLifebloom = data.LifebloomTicks * 0.02f * stats.Talents.MalfurionsGift;
+
+			Action action = new Action();
+			action.Time = tollb.Time + cchtsPerLifebloom * ccht.Time; ;
+			action.Direct = (tollbHeals ? tollb.Direct : 0) + cchtsPerLifebloom * ccht.Direct;
+			action.OverTime = (tollbHeals ? tollb.OverTime : 0);
+			action.Mana = tollb.Mana;
+			return action;
+		}
+
+		Action[] buildActions(TreeStats stats, out TreeComputedData data)
+		{
+			data = new TreeComputedData();
+			Action[] actions = new Action[(int)TreeAction.Count];
+
+			SpellData nourish = new SpellData("Nourish", 10, 3000, 2403, 2791, 2660);
+			SpellData healingTouch = new SpellData("Healing Touch", 30, 3000, 7211, 8515, 8060);
+			SpellData regrowth = new SpellData("Regrowth", 35, 1500, 3383, 3775, 2936, 361, 296);
+			SpellData swiftmend = new SpellData("Swiftmend", 10, 1500, 5228, 5228, 5360, 5228, 5360);
+			SpellData rejuvenation = new SpellData("Rejuvenation", 20, 1500, 0, 0, 0, 1307, 1340);
+			SpellData lifebloom = new SpellData("Lifebloom", 7, 1500, 1847, 1847, 2840, 228, 234);
+			SpellData wildGrowth = new SpellData("Wild Growth", 27, 1500, 0, 0, 0, 531, 546);
+			SpellData tranquility = new SpellData("Tranquility", 32, 8000, 3882, 3882, 3980, 343, 680);
+
+			int T11Count;
+			character.SetBonusCount.TryGetValue("Stormrider's Vestments", out T11Count);
+			if (T11Count >= 2)
+				lifebloom.ExtraTickCrit += 0.05f;
+
+			swiftmend.ExtraDirectBonus += 0.02f * stats.Talents.Genesis;
+
+			rejuvenation.ExtraTickBonus += stats.Talents.BlessingOfTheGrove * 0.02f;
+
+			nourish.TimeMS -= 250 * stats.Talents.Naturalist;
+			healingTouch.TimeMS -= 250 * stats.Talents.Naturalist;
+
+			rejuvenation.ExtraTickBonus += 0.05f * stats.Talents.ImprovedRejuvenation;
+			swiftmend.ExtraTickBonus += 0.05f * stats.Talents.ImprovedRejuvenation;
+			swiftmend.ExtraDirectBonus += 0.05f * stats.Talents.ImprovedRejuvenation;
+
+			nourish.ExtraCritBonus = healingTouch.ExtraCritBonus = regrowth.ExtraCritBonus = swiftmend.ExtraCritBonus = 0.1f * stats.Talents.LivingSeed;
+
+			regrowth.ExtraDirectCrit += 0.2f * stats.Talents.NaturesBounty;
+			regrowth.ExtraTickCrit += 0.2f * stats.Talents.NaturesBounty;
+
+			nourish.ExtraDirectBonus += 0.05f * stats.Talents.EmpoweredTouch;
+			healingTouch.ExtraDirectBonus += 0.05f * stats.Talents.EmpoweredTouch;
+			regrowth.ExtraDirectBonus += 0.05f * stats.Talents.EmpoweredTouch;
+
+			// formula from TreeCalcs
+			// TODO: the haste value is probably kind of wrong, and we should all the Rejuvenation data per-proc, but, well, it doesn't matter much
+			rejuvenation.InstantTicks = stats.Talents.GiftOfTheEarthmother * 0.05f * Math.Floor(4.0f * (1 + StatConversion.GetSpellHasteFromRating((float)stats.HasteRating)) + 0.5f) * 1.0135f;
+			lifebloom.ExtraDirectMult = stats.Talents.GiftOfTheEarthmother * 0.05f;
+
+			if (stats.Talents.SwiftRejuvenation > 0)
+				rejuvenation.TimeMS = 1000;
+
+			if (stats.Talents.GlyphOfRejuvination)
+				rejuvenation.ExtraTickBonus += 0.1f;
+
+			if (stats.Talents.GlyphOfLifebloom)
+			{
+				lifebloom.ExtraDirectCrit += 0.1f;
+				lifebloom.ExtraTickCrit += 0.1f;
+			}
+
+
+			Action action;
+			data.LifebloomTicks = stats.computeHoT(1000, 10000, out data.LifebloomDuration, out data.LifebloomTPS);
+			data.LifebloomDuration /= 1000.0;
+			data.LifebloomTPS *= 1000.0;
+
+			action = computeSpell(stats, lifebloom);
+			if (stats.TreeOfLifeUptime > 0)
+			{
+				actions[(int)TreeAction.RaidTolLb] = applySymbiosis(action, stats.Symbiosis, opts.RaidSTSymbiosisRate);
+				actions[(int)TreeAction.RaidTolLb].DirectPS *= opts.ToLLifebloomEffectiveHealing;
+				actions[(int)TreeAction.RaidTolLb].OverTimePS *= opts.ToLLifebloomEffectiveHealing;
+			}
+
+			double reducedLifebloomDuration = data.LifebloomDuration - opts.LifebloomWastedDuration * stats.HastedSecond;
+			if (reducedLifebloomDuration < stats.HastedSecond * 3)
+				reducedLifebloomDuration = stats.HastedSecond * 3;
+			action.OverTimePS *= 3.0f * data.LifebloomTicks * reducedLifebloomDuration / data.LifebloomDuration;
+			action.DirectPS = 0;
+			data.LifebloomDuration = reducedLifebloomDuration;
+
+			actions[(int)TreeAction.RaidReLifebloom] = applySymbiosis(action, stats.Symbiosis, opts.RejuvenationTankDuringRaid ? 1.0f : opts.RaidSTSymbiosisRate);
+			actions[(int)TreeAction.TankReLifebloom] = applySymbiosis(action, stats.Symbiosis, 1.0f);
+
+			double wgTicks = stats.computeHoT(1000, 7000);
+			double wgTargets = (stats.Talents.GlyphOfWildGrowth ? 6 : 5) + stats.TreeOfLifeUptime * 2;
+			action = computeSpell(stats, wildGrowth);
+			action.OverTimePS *= wgTicks;
+			actions[(int)TreeAction.RaidWildGrowth] = applySymbiosis(action, stats.Symbiosis, opts.WildGrowthSymbiosisRate);
+			actions[(int)TreeAction.RaidWildGrowth].OverTimePS *= wgTargets * opts.WildGrowthEffectiveHealing;
+			actions[(int)TreeAction.TankWildGrowth] = applySymbiosis(action, stats.Symbiosis, 1.0f);
+			if(opts.TankRaidHealing)
+				actions[(int)TreeAction.TankWildGrowth].OverTimePS *= wgTargets * opts.WildGrowthEffectiveHealing;
+
+			action = computeSpell(stats, rejuvenation);
+			action.OverTimePS *= stats.computeHoT(3000, 12000, out data.RejuvenationDuration);
+			actions[(int)TreeAction.RaidRejuvenation] = applySymbiosis(action, stats.Symbiosis, opts.RaidSTSymbiosisRate);
+			actions[(int)TreeAction.RaidRejuvenation].OverTimePS *= opts.RejuvenationEffectiveHealing;
+			actions[(int)TreeAction.TankRejuvenation] = applySymbiosis(action, stats.Symbiosis, 1.0f);
+
+			action = applySymbiosis(computeSpell(stats, swiftmend), stats.Symbiosis, 1.0f);
+			if (!stats.Talents.GlyphOfSwiftmend)
+				action.Direct -= actions[(int)TreeAction.RaidRejuvenation].OverTime * 0.5f;
+			action.OverTimePS *= wgTicks * 0.04f * stats.Talents.Efflorescence * (1.0f + stats.Talents.MasterShapeshifter * 0.04f);
+			actions[(int)TreeAction.RaidSwiftmend] = (Action)action.Clone();
+			actions[(int)TreeAction.RaidSwiftmend].OverTimePS *= Math.Min(opts.EfflorescenceTargets, 3.0f);
+			actions[(int)TreeAction.TankSwiftmend] = (Action)action.Clone();
+			actions[(int)TreeAction.TankSwiftmend].OverTimePS *= (opts.TankRaidHealing ? Math.Max(Math.Min(opts.EfflorescenceTargets, 3.0f), 1.0f) : 1.0f);
+
+			action = computeSpell(stats, healingTouch);
+
+			// add the NS effect as an amortized extra heal to each HT
+			if (stats.Talents.NaturesSwiftness > 0 && stats.Talents.GlyphOfHealingTouch)
+			{
+				double swiftHtFraction = (10.0 / (180.0 + opts.NaturesSwiftnessCastDelay));
+				action.ChangeTime(action.Time + swiftHtFraction * stats.HastedSecond * 1.5);
+				action.DirectPS *= 1 + swiftHtFraction * 1.5;
+			}
+
+			actions[(int)TreeAction.RaidHealingTouch] = applySymbiosis(action, stats.Symbiosis, opts.RaidSTSymbiosisRate);
+			actions[(int)TreeAction.RaidHealingTouch].Direct *= opts.HealingTouchEffectiveHealing;
+			actions[(int)TreeAction.RaidClearHT] = applyCC(actions[(int)TreeAction.RaidHealingTouch]);
+			actions[(int)TreeAction.TankHealingTouch] = applySymbiosis(action, stats.Symbiosis, 1.0f);
+			actions[(int)TreeAction.TankClearHT] = applyCC(actions[(int)TreeAction.TankHealingTouch]);
+			if (stats.Talents.NaturesSwiftness > 0)
+			{
+				double heal = action.Direct * 1.5f;
+				action.Time = stats.HastedSecond * 1.5f;
+				action.Direct = heal;
+			}
+			else
+			{
+				action.DirectPS = 0;
+			}
+
+			actions[(int)TreeAction.RaidSwiftHT] = applySymbiosis(action, stats.Symbiosis, opts.RaidSTSymbiosisRate);
+			actions[(int)TreeAction.RaidSwiftHT].DirectPS *= opts.HealingTouchEffectiveHealing;
+			actions[(int)TreeAction.TankSwiftHT] = applySymbiosis(action, stats.Symbiosis, 1.0f);
+
+			action = computeSpell(stats, regrowth);
+			action.OverTimePS *= stats.computeHoT(2000, 6000 + (stats.Talents.GlyphOfRegrowth ? (int)(Math.Min(opts.GlyphOfRegrowthExtraDuration, calc.FightLength) * 1000.0) : 0));
+			actions[(int)TreeAction.RaidRegrowth] = applySymbiosis(action, stats.Symbiosis, opts.RaidSTSymbiosisRate);
+			actions[(int)TreeAction.RaidRegrowth].DirectPS *= opts.NourishEffectiveHealing;
+			actions[(int)TreeAction.RaidClearRegrowth] = applyCC(actions[(int)TreeAction.RaidRegrowth]);
+			actions[(int)TreeAction.RaidClearRegrowth].DirectPS *= opts.NourishEffectiveHealing;
+			actions[(int)TreeAction.TankRegrowth] = applySymbiosis(action, stats.Symbiosis, 1.0f);
+			actions[(int)TreeAction.TankClearRegrowth] = applyCC(actions[(int)TreeAction.TankRegrowth]);
+
+			action = computeSpell(stats, nourish);
+			actions[(int)TreeAction.RaidNourish] = applySymbiosis(action, stats.Symbiosis, opts.RaidSTSymbiosisRate, true);
+			actions[(int)TreeAction.RaidNourish].Direct *= opts.NourishEffectiveHealing;
+			actions[(int)TreeAction.TankNourish] = applySymbiosis(action, stats.Symbiosis, 1.0f, true);
+
+			actions[(int)TreeAction.RaidRj2NourishNB] = buildNourishNB(stats, actions[(int)TreeAction.RaidRejuvenation], data.RejuvenationDuration, 2, true, actions[(int)TreeAction.RaidNourish]);
+			actions[(int)TreeAction.RaidRj3NourishNB] = buildNourishNB(stats, actions[(int)TreeAction.RaidRejuvenation], data.RejuvenationDuration, 3, true, actions[(int)TreeAction.RaidNourish]);
+			actions[(int)TreeAction.TankRj2NourishNB] = buildNourishNB(stats, actions[(int)TreeAction.RaidRejuvenation], data.RejuvenationDuration, 2, opts.TankRaidHealing, actions[(int)TreeAction.TankNourish]);
+
+			actions[(int)TreeAction.RaidTranquility] = applySymbiosis(computeSpell(stats, tranquility), stats.Symbiosis, opts.TranquilitySymbiosisRate);
+			actions[(int)TreeAction.RaidTranquility].DirectPS *= 20;
+			actions[(int)TreeAction.RaidTranquility].OverTimePS *= 20 * stats.computeHoT(2000, 8000);
+
+			if (stats.TreeOfLifeUptime > 0)
+			{
+				actions[(int)TreeAction.RaidTolLbCcHt] = buildTolLbCcHt(stats, data, actions[(int)TreeAction.RaidTolLb], true, actions[(int)TreeAction.RaidClearHT]);
+				actions[(int)TreeAction.TankTolLbCcHt] = buildTolLbCcHt(stats, data, actions[(int)TreeAction.RaidTolLb], opts.TankRaidHealing, actions[(int)TreeAction.TankClearHT]);
+			}
+
+			for (int i = 0; i < (int)TreeAction.Count; ++i)
+			{
+				if (actions[i] == null)
+					actions[i] = new Action();
+
+				actions[i].DirectPS *= 1 + stats.TreeOfLifeUptime * 0.15f;
+				actions[i].OverTimePS *= 1 + stats.TreeOfLifeUptime * 0.15f;
+			}
+			return actions;
+		}
+
+		ActionDistribution[] computeRaidHealing(bool burst, out int[] fillers)
+		{
+			ActionDistribution[] dists = new ActionDistribution[calc.DivisionFractions.Length];
+			for (int div = 0; div < calc.DivisionFractions.Length; ++div)
+			{
+				TreeStats stats = calc.DivisionStats[div];
+				TreeComputedData data = DivisionData[div];
+
+				bool refreshLBWithDHs = stats.Talents.EmpoweredTouch == 2 && opts.RefreshLifebloomWithDirectHeals;
+				Action[] actions = calc.DivisionActions[div];
+				ActionDistribution dist = new ActionDistribution(actions);
+				if (!burst)
+					dist.MaxMPS = calc.ManaRegen;
+
+				// TODO: add option to choose when to use tranquility (maybe even model it as a division?)
+				dist.AddActionPeriodically((int)TreeAction.RaidTranquility, 8 * 60 - (150 * stats.Talents.MalfurionsGift) + opts.TranquilityCastDelay);
+				if (opts.RejuvenationTankDuringRaid)
+					dist.AddActionPeriodically((int)TreeAction.TankReLifebloom, data.LifebloomDuration);
+				else
+					dist.AddActionPeriodically((int)TreeAction.RaidReLifebloom, data.LifebloomDuration);
+
+				if (stats.Talents.WildGrowth > 0)
+					dist.AddActionPeriodically((int)TreeAction.RaidWildGrowth, 8 + opts.WildGrowthCastDelay);
+				
+				if (stats.Restoration)
+				{
+					dist.AddActionPeriodically((int)TreeAction.RaidSwiftmend, 15 + opts.SwiftmendCastDelay);
+					// TODO: maybe restore this, the issue is that it would not count for Nature's Bounty,
+					//       and anyway it's possible to swiftmend Regrowth and other druids' hots
+
+					//if (!opts.RejuvenationTankDuringRaid)
+					//	dist.AddAction((int)TreeAction.RaidRejuvenation, 1.0f / actions[(int)TreeAction.RaidSwiftmend].Cooldown);
+				}
+
+				if (opts.RejuvenationTankDuringRaid)
+					dist.AddActionPeriodically((int)TreeAction.TankRejuvenation, data.RejuvenationDuration);
+
+				double dhrate = 0.0f;
+
+				// CCs from Lifeblooms on raid are handled using the LifebloomRaidAndCCHT combined action
+
+				// TODO: maybe reenable NG-proccing regrowths on CC? (doesn't work well with the proc-syncing we want, maybe add an option)
+				bool procNaturesGraceWithCCs = false;
+
+				bool naturesGraceHandled = false;
+
+				double ccrate = data.LifebloomTPS * 0.02f * stats.Talents.MalfurionsGift;
+				if (ccrate != 0.0f)
+				{
+					if (procNaturesGraceWithCCs && stats.Talents.NaturesGrace > 0)
+					{
+						naturesGraceHandled = true;
+						dist.AddAction(refreshLBWithDHs ? (int)TreeAction.TankClearRegrowth : (int)TreeAction.RaidClearRegrowth, 1.0f / 60.0f * actions[(int)TreeAction.RaidClearRegrowth].Time);
+						ccrate -= 1.0f / 60.0f;
+						dhrate += 1.0f / 60.0f;
+					}
+
+					if (!burst)
+					{
+						dist.AddAction(refreshLBWithDHs ? (int)TreeAction.TankClearHT : (int)TreeAction.RaidClearHT, ccrate * actions[(int)TreeAction.RaidClearHT].Time);
+						dhrate += ccrate;
+					}
+				}
+
+				if (!naturesGraceHandled && stats.Talents.NaturesGrace > 0)
+				{
+					dist.AddAction(refreshLBWithDHs ? (int)TreeAction.TankRegrowth : (int)TreeAction.RaidRegrowth, 1.0f / 60.0f * actions[(int)TreeAction.RaidRegrowth].Time);
+					dhrate += 1.0f / 60.0f;
+				}
+
+				// TODO: should allow to use LB CC HTs to refresh the main LB in ToL
+				if (refreshLBWithDHs)
+				{
+					int lb = opts.RejuvenationTankDuringRaid ? (int)TreeAction.TankReLifebloom : (int)TreeAction.RaidReLifebloom;
+					dist.TotalFraction -= dist.Fraction[lb];
+					dist.Fraction[lb] = 0;
+					dist.TotalMPS -= dist.MPS[lb];
+					dist.MPS[lb] = 0;
+
+					double forcedhrate = 1.0f / data.LifebloomDuration - dhrate;
+					if (!burst)
+						dist.AddAction((int)TreeAction.TankNourish, forcedhrate * actions[(int)TreeAction.TankNourish].Time);
+					else
+						dist.AddAction((int)TreeAction.TankHealingTouch, forcedhrate * actions[(int)TreeAction.TankHealingTouch].Time);
+				}
+
+				// Glyph of Healing Touch is handled by adding the amortized Swift HT to normal healing touches
+				dist.AddActionPeriodically((int)TreeAction.RaidSwiftHT, 180.0 + opts.NaturesSwiftnessCastDelay);
+				dists[div] = dist;
+			}
+
+			List<int> fillersList = new List<int>();
+			fillersList.Add((int)TreeAction.RaidRejuvenation);
+			fillersList.Add((int)TreeAction.RaidHealingTouch);
+			fillersList.Add((int)TreeAction.RaidNourish);
+			fillersList.Add(opts.RejuvenationTankDuringRaid ? (int)TreeAction.RaidRj2NourishNB : (int)TreeAction.RaidRj3NourishNB);
+			fillersList.Add((int)TreeAction.RaidTolLb);
+			fillersList.Add((int)TreeAction.RaidTolLbCcHt);
+			fillers = fillersList.ToArray();
+
+			return dists;
+		}
+
+		// TODO: add nature's bounty through amortized 3 rj + nourish and 2 rj + nourish actions
+
+		ActionDistribution[] computeTankHealing(bool infMana, out int[] fillers)
+		{
+			ActionDistribution[] dists = new ActionDistribution[calc.DivisionFractions.Length];
+			for (int div = 0; div < calc.DivisionFractions.Length; ++div)
+			{
+				TreeStats stats = calc.DivisionStats[div];
+				TreeComputedData data = DivisionData[div];
+				Action[] actions = calc.DivisionActions[div];
+				ActionDistribution dist = new ActionDistribution(actions);
+				if (!infMana)
+					dist.MaxMPS = calc.ManaRegen;
+
+				dist.AddActionPeriodically((int)TreeAction.TankReLifebloom, data.LifebloomDuration);
+				if (stats.Talents.EmpoweredTouch != 0)
+				{
+					dist.TotalFraction -= dist.Fraction[(int)TreeAction.TankReLifebloom];
+					dist.Fraction[(int)TreeAction.TankReLifebloom] = 0;
+					dist.TotalMPS -= dist.MPS[(int)TreeAction.TankReLifebloom];
+					dist.MPS[(int)TreeAction.TankReLifebloom] = 0;
+				}
+
+				dist.AddActionPeriodically((int)TreeAction.TankRejuvenation, data.RejuvenationDuration);
+				
+				if (stats.Restoration && opts.TankSwiftmend)
+					dist.AddActionPeriodically((int)TreeAction.TankSwiftmend, 15 + opts.SwiftmendCastDelay);
+
+				if (!infMana && opts.TankWildGrowth && stats.Talents.WildGrowth > 0)
+					dist.AddActionPeriodically((int)TreeAction.TankWildGrowth, 8 + opts.WildGrowthCastDelay);
+				
+				double ccrate = data.LifebloomTPS * 0.02f * stats.Talents.MalfurionsGift;
+				if (ccrate != 0.0f)
+				{
+					if (stats.Talents.NaturesGrace > 0)
+					{
+						dist.AddAction((int)TreeAction.TankClearRegrowth, 1.0f / 60.0f * actions[(int)TreeAction.TankClearRegrowth].Time);
+						ccrate -= 1.0f / 60.0f;
+					}
+
+					dist.AddAction((int)TreeAction.TankClearHT, ccrate * actions[(int)TreeAction.RaidClearHT].Time);
+				}
+				else if (stats.Talents.NaturesGrace > 0)
+					dist.AddAction((int)TreeAction.TankRegrowth, 1.0f / 60.0f * actions[(int)TreeAction.TankRegrowth].Time);
+
+				// Glyph of Healing Touch is handled by adding the amortized Swift HT to normal healing touches
+				dist.AddActionPeriodically((int)TreeAction.TankSwiftHT, 180.0 + opts.NaturesSwiftnessCastDelay);
+				dists[div] = dist;
+			}
+
+			List<int> fillersList = new List<int>();
+			fillersList.Add((int)TreeAction.TankHealingTouch);
+			fillersList.Add((int)TreeAction.TankNourish);
+			if(character.DruidTalents.NaturesBounty > 0)
+				fillersList.Add((int)TreeAction.TankRj2NourishNB);
+			fillersList.Add((int)TreeAction.TankTolLbCcHt);
+			fillers = fillersList.ToArray();
+
+			return dists;
+		}
+	}
+}
Index: Rawr3/Rawr.Tree/CalculationOptionsPanelTree.WPF.xaml
===================================================================
--- Rawr3/Rawr.Tree/CalculationOptionsPanelTree.WPF.xaml	(revision 60557)
+++ Rawr3/Rawr.Tree/CalculationOptionsPanelTree.WPF.xaml	(working copy)
@@ -7,49 +7,232 @@
     xmlns:controls="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
     xmlns:inputToolkit="clr-namespace:System.Windows.Controls;assembly=System.Windows.Controls.Input.WPFToolkit"
     xmlns:System="clr-namespace:System;assembly=mscorlib"
-    mc:Ignorable="d"
-    d:DesignWidth="330" d:DesignHeight="600"
-    xmlns:local="clr-namespace:Rawr.Tree"
-    x:Class="Rawr.Tree.CalculationOptionsPanelTree" 
-    >
+    mc:Ignorable="d" xmlns:local="clr-namespace:Rawr.Tree"
+    x:Class="Rawr.Tree.CalculationOptionsPanelTree" d:DesignHeight="550" d:DesignWidth="338">
 
     <UserControl.Resources>
         <local:CalculationOptionsTree x:Key="CalculationOptionsTreeDataSource" d:IsDataSource="True"/>
     </UserControl.Resources>
+	<TabControl x:Name="LayoutRoot" DataContext="{Binding Source={StaticResource CalculationOptionsTreeDataSource}}">
+		<TabItem Header="General">
+			<Grid>
+				<Grid.ColumnDefinitions>
+					<ColumnDefinition Width="Auto"/>
+					<ColumnDefinition Width="Auto"/>
+					<ColumnDefinition Width="*" />
+				</Grid.ColumnDefinitions>
+				<Grid.RowDefinitions>
+					<RowDefinition Height="Auto"/>
+					<RowDefinition Height="Auto"/>
+					<RowDefinition Height="Auto"/>
+					<RowDefinition Height="Auto"/>
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+				</Grid.RowDefinitions>
 
-    <Grid x:Name="LayoutRoot" DataContext="{Binding Source={StaticResource CalculationOptionsTreeDataSource}}">
-        <Grid.ColumnDefinitions>
-            <ColumnDefinition Width="Auto"/>
-            <ColumnDefinition Width="*"/>
-            <ColumnDefinition Width="Auto" />
-        </Grid.ColumnDefinitions>
-        <Grid.RowDefinitions>
-            <RowDefinition Height="Auto"/>
-            <RowDefinition Height="Auto"/>
-            <RowDefinition Height="Auto"/>
-            <RowDefinition Height="Auto"/>
-            <RowDefinition Height="Auto"/>
-            <RowDefinition Height="Auto"/>
-        </Grid.RowDefinitions>
+				<Border Grid.ColumnSpan="5" Background="AliceBlue" BorderBrush="LightSteelBlue" BorderThickness="1">
+					<TextBlock Margin="4" FontWeight="Bold" Text="Weights" VerticalAlignment="Center" />
+				</Border>
 
-        <!-- ========= Weighting Adjustments ========= -->
-        <Border Grid.Row="0" Grid.Column="0" Grid.ColumnSpan="4" Background="AliceBlue" BorderBrush="LightSteelBlue" BorderThickness="1">
-            <TextBlock Margin="4" FontWeight="Bold" Text="Weighting Adjustments" VerticalAlignment="Center" />
-        </Border>
-        <TextBlock Grid.Row="1" Grid.ColumnSpan="4" Margin="4,2" TextWrapping="Wrap" FontSize="10"
-            Text="The following settings will adjust the overall scores for each type. This does not involve Stat Weights as described by Pawn, SimCraft or other similar utilities. These are meant to describe your general importance to each point." />
-        <!-- Burst v Sustained -->
-        <TextBlock Margin="4,2" Grid.Row="2" Text="Burst vs Sustained:" TextWrapping="Wrap" VerticalAlignment="Center"/>
-        <Slider Grid.Column="1" Grid.Row="2" Maximum="100" SmallChange="1" Value="{Binding Path=BSRatio, Mode=TwoWay}" Margin="2" ToolTipService.ToolTip="Percentage of combined value that comes from sustained"/>
-        <inputToolkit:NumericUpDown Margin="2" Grid.Column="2" Grid.Row="2" Value="{Binding Path=BSRatio, Mode=TwoWay}" Maximum="100" DecimalPlaces="0" MinWidth="50" />
-        <!-- Survival Multiplier -->
-        <TextBlock Margin="4,2" Grid.Row="3" Text="Survival Multiplier:" TextWrapping="Wrap" VerticalAlignment="Center"/>
-        <Slider Grid.Column="1" Grid.Row="3" Maximum="10" LargeChange="1" SmallChange="1" Value="{Binding Path=SurvValuePer100, Mode=TwoWay}" Margin="2"/>
-        <inputToolkit:NumericUpDown Margin="2" Grid.Column="2" Grid.Row="3" Value="{Binding Path=SurvValuePer100, Mode=TwoWay}" Maximum="10" DecimalPlaces="0" MinWidth="50" />
-        <!-- ========= Misc ========= -->
-        <Border Grid.Row="4" Grid.Column="0" Grid.ColumnSpan="4" Background="AliceBlue" BorderBrush="LightSteelBlue" BorderThickness="1">
-            <TextBlock Margin="4" FontWeight="Bold" Text="Misc" VerticalAlignment="Center" />
-        </Border>
-        <CheckBox Margin="4,2,2,2" Content="Cast Innervates on Self" Grid.Row="5" IsChecked="{Binding Mode=TwoWay, Path=Innervates}" Grid.ColumnSpan="3" />
-    </Grid>
+				<Grid Grid.ColumnSpan="3" Grid.Row="1" Grid.RowSpan="3">
+					<Grid.ColumnDefinitions>
+						<ColumnDefinition Width="Auto"/>
+						<ColumnDefinition Width="*" />
+						<ColumnDefinition Width="Auto" />
+						<ColumnDefinition Width="Auto" />
+					</Grid.ColumnDefinitions>
+					<Grid.RowDefinitions>
+						<RowDefinition Height="Auto"/>
+						<RowDefinition Height="Auto"/>
+						<RowDefinition Height="Auto"/>
+					</Grid.RowDefinitions>
+					<TextBlock Margin="4,2" Grid.Row="0" Text="Raid" TextWrapping="Wrap" VerticalAlignment="Center" HorizontalAlignment="Right" />
+					<TextBlock Text="Tank" TextWrapping="Wrap" VerticalAlignment="Center" Grid.Column="2" Grid.Row="0" Height="Auto" Margin="4,2" />
+					<Slider Grid.Column="1" Grid.Row="0" Maximum="100" SmallChange="1" Value="{Binding Path=TankRatio, Converter={StaticResource PercentConverter}, Mode=TwoWay}" Margin="2,2,0,2" Grid.ColumnSpan="1" />
+					<inputToolkit:NumericUpDown Margin="2" Grid.Column="4" Grid.Row="0" Value="{Binding Path=TankRatio, Converter={StaticResource PercentConverter}, Mode=TwoWay}" Maximum="100" DecimalPlaces="0" MinWidth="50" />
+
+					<TextBlock Margin="4,2" Grid.Row="1" Text="Raid Sustained" TextWrapping="Wrap" VerticalAlignment="Center" HorizontalAlignment="Right" />
+					<TextBlock Margin="4,2" Grid.Row="1" Text="Raid Burst" TextWrapping="Wrap" VerticalAlignment="Center" Grid.Column="2" />
+					<Slider Grid.Column="1" Grid.Row="1" Maximum="100" SmallChange="1" Value="{Binding Path=RaidBurstRatio, Converter={StaticResource PercentConverter}, Mode=TwoWay}" Margin="2,2,0,2" Grid.ColumnSpan="1" />
+					<inputToolkit:NumericUpDown Margin="2" Grid.Column="4" Grid.Row="1" Value="{Binding Path=RaidBurstRatio, Converter={StaticResource PercentConverter}, Mode=TwoWay}" Maximum="100" DecimalPlaces="0" MinWidth="50" />
+
+					<TextBlock Margin="4,2" Grid.Row="2" Text="Tank Sustained" TextWrapping="Wrap" VerticalAlignment="Center" HorizontalAlignment="Right" />
+					<TextBlock Margin="4,2" Grid.Row="2" Text="Tank Burst" TextWrapping="Wrap" VerticalAlignment="Center" Grid.Column="2" />
+					<Slider Grid.Column="1" Grid.Row="2" Maximum="100" SmallChange="1" Value="{Binding Path=TankBurstRatio, Converter={StaticResource PercentConverter}, Mode=TwoWay}" Margin="2,2,0,2" Grid.ColumnSpan="1" />
+					<inputToolkit:NumericUpDown Margin="2" Grid.Column="4" Grid.Row="2" Value="{Binding Path=TankBurstRatio, Converter={StaticResource PercentConverter}, Mode=TwoWay}" Maximum="100" DecimalPlaces="0" MinWidth="50" />
+				</Grid>
+
+				<Border Grid.Row="4" Grid.ColumnSpan="5" Background="AliceBlue" BorderBrush="LightSteelBlue" BorderThickness="1">
+					<TextBlock Margin="4" FontWeight="Bold" Text="General" VerticalAlignment="Center" />
+				</Border>
+
+				<CheckBox Grid.Row="5" IsChecked="{Binding Path=Restoration, Mode=TwoWay}" MinWidth="50" Content="Restoration specialization" Grid.ColumnSpan="3" Margin="4,2,2,2" />
+
+				<Border Grid.Row="6" Grid.ColumnSpan="5" Background="AliceBlue" BorderBrush="LightSteelBlue" BorderThickness="1">
+					<TextBlock Margin="4" FontWeight="Bold" Text="Innervate" VerticalAlignment="Center" />
+				</Border>
+
+				<CheckBox Grid.Column="0" Grid.Row="7" IsChecked="{Binding Path=TimedInnervates, Mode=TwoWay}" MinWidth="50" Content="Time Innervate with intellect procs" Margin="4,2,2,2" Grid.ColumnSpan="5"/>
+				<CheckBox Grid.Column="0" Grid.Row="8" IsChecked="{Binding Path=InnervateOther, Mode=TwoWay}" MinWidth="50" Content="Innervate someone else" Margin="4,2,2,2" Grid.ColumnSpan="5"/>
+				<TextBlock Grid.ColumnSpan="1" Margin="4,2,2,2" Text="External innervate(s) size:" TextWrapping="NoWrap" VerticalAlignment="Center" Grid.Row="9" />
+				<inputToolkit:NumericUpDown Margin="2" Grid.Column="1" Grid.Row="9" Value="{Binding Path=ExternalInnervateSize, Mode=TwoWay}" DecimalPlaces="0" MinWidth="50" Maximum="1000000" />
+				<Border Grid.Row="10" Grid.ColumnSpan="5" Background="AliceBlue" BorderBrush="LightSteelBlue" BorderThickness="1">
+					<TextBlock Margin="4" FontWeight="Bold" Text="Timing (in seconds)" VerticalAlignment="Center" />
+				</Border>
+
+				<CheckBox Grid.Column="0" Grid.Row="11" IsChecked="{Binding Path=SeparateHasteEffects, Mode=TwoWay}" MinWidth="50" Content="Use short CD haste effects separately" Margin="4,2,2,2" Grid.ColumnSpan="5"/>
+				
+				<TextBlock Grid.ColumnSpan="1" Margin="4,2,2,2" Text="Lifebloom wasted duration:" TextWrapping="NoWrap" VerticalAlignment="Center" Grid.Row="12" />
+				<inputToolkit:NumericUpDown Margin="2" Grid.Column="1" Grid.Row="12" Value="{Binding Path=LifebloomWastedDuration, Mode=TwoWay}" Maximum="6" DecimalPlaces="2" MinWidth="50" />
+
+				<TextBlock Grid.ColumnSpan="1" Margin="4,2,2,2" Text="Wild Growth cast delay:" TextWrapping="NoWrap" VerticalAlignment="Center" Grid.Row="13" />
+				<inputToolkit:NumericUpDown Margin="2" Grid.Column="1" Grid.Row="13" Value="{Binding Path=WildGrowthCastDelay, Mode=TwoWay}" DecimalPlaces="2" MinWidth="50" Maximum="10000" />
+
+				<TextBlock Grid.ColumnSpan="1" Margin="4,2,2,2" Text="Swiftmend cast delay:" TextWrapping="NoWrap" VerticalAlignment="Center" Grid.Row="14" />
+				<inputToolkit:NumericUpDown Margin="2" Grid.Column="1" Grid.Row="14" Value="{Binding Path=SwiftmendCastDelay, Mode=TwoWay}" DecimalPlaces="2" MinWidth="50" Maximum="10000" />
+				<TextBlock Grid.ColumnSpan="1" Margin="4,2,2,2" Text="Nature's Swiftness cast delay:" TextWrapping="NoWrap" VerticalAlignment="Center" Grid.Row="15" />
+				<inputToolkit:NumericUpDown Margin="2" Grid.Column="1" Grid.Row="15" Value="{Binding Path=NaturesSwiftnessCastDelay, Mode=TwoWay}" DecimalPlaces="2" MinWidth="50" Maximum="10000" />
+
+				<TextBlock Grid.ColumnSpan="1" Margin="4,2,2,2" Text="Tranquility cast delay:" TextWrapping="NoWrap" VerticalAlignment="Center" Grid.Row="16" />
+				<inputToolkit:NumericUpDown Margin="2" Grid.Column="1" Grid.Row="16" Value="{Binding Path=TranquilityCastDelay, Mode=TwoWay}" DecimalPlaces="2" MinWidth="50" Maximum="10000" />
+
+				<TextBlock Grid.ColumnSpan="1" Margin="4,2,2,2" Text="Glyph of Regrowth extra time:" TextWrapping="NoWrap" VerticalAlignment="Center" Grid.Row="17" />
+				<inputToolkit:NumericUpDown Margin="2" Grid.Column="1" Grid.Row="17" Value="{Binding Path=GlyphOfRegrowthExtraDuration, Mode=TwoWay}" DecimalPlaces="2" MinWidth="50" Maximum="1000" />
+			</Grid>
+		</TabItem>
+		<TabItem Header="Tank">
+			<Grid>
+				<Grid.ColumnDefinitions>
+					<ColumnDefinition Width="Auto"/>
+					<ColumnDefinition Width="Auto"/>
+					<ColumnDefinition Width="*" />
+				</Grid.ColumnDefinitions>
+				<Grid.RowDefinitions>
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+				</Grid.RowDefinitions>
+
+				<Border Grid.Row="0" Grid.ColumnSpan="5" Background="AliceBlue" BorderBrush="LightSteelBlue" BorderThickness="1">
+					<TextBlock Margin="4" FontWeight="Bold" Text="Tank healing" VerticalAlignment="Center" />
+				</Border>
+
+				<TextBlock Grid.ColumnSpan="1" Margin="4,2,2,2" Text="Unevenly allocated filler mana:" TextWrapping="NoWrap" VerticalAlignment="Center" Grid.Row="1" />
+				<inputToolkit:NumericUpDown Margin="2" Grid.Column="1" Grid.Row="1" Value="{Binding Path=TankUnevenlyAllocatedFillerMana, Converter={StaticResource PercentConverter}, Mode=TwoWay}" Maximum="100" DecimalPlaces="0" MinWidth="50" />
+
+				<CheckBox Grid.Column="0" Grid.Row="2" IsChecked="{Binding Path=TankRaidHealing, Mode=TwoWay}" MinWidth="50" Content="Include collateral raid healing" Margin="4,2,2,2" Grid.ColumnSpan="3"/>
+				<CheckBox Grid.Column="0" Grid.Row="3" IsChecked="{Binding Path=TankSwiftmend, Mode=TwoWay}" MinWidth="50" Content="Use Swiftmend/Efforescence" Margin="4,2,2,2" Grid.ColumnSpan="3"/>
+				<CheckBox Grid.Column="0" Grid.Row="4" IsChecked="{Binding Path=TankWildGrowth, Mode=TwoWay}" MinWidth="50" Content="Use Wild Growth" Margin="4,2,2,2" Grid.ColumnSpan="3"/>
+			</Grid>
+		</TabItem>
+		<TabItem Header="Raid">
+			<Grid>
+				<Grid.ColumnDefinitions>
+					<ColumnDefinition Width="Auto"/>
+					<ColumnDefinition Width="Auto"/>
+					<ColumnDefinition Width="*" />
+				</Grid.ColumnDefinitions>
+				<Grid.RowDefinitions>
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto"/>
+					<RowDefinition Height="Auto"/>
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+				</Grid.RowDefinitions>
+				<Border Grid.ColumnSpan="5" Background="AliceBlue" BorderBrush="LightSteelBlue" BorderThickness="1">
+					<TextBlock Margin="4" FontWeight="Bold" Text="Raid healing" VerticalAlignment="Center" />
+				</Border>
+				
+				<TextBlock Grid.ColumnSpan="1" Margin="4,2,2,2" Text="Unevenly allocated filler mana:" TextWrapping="NoWrap" VerticalAlignment="Center" Grid.Row="1" />
+				<inputToolkit:NumericUpDown Margin="2" Grid.Column="1" Grid.Row="1" Value="{Binding Path=RaidUnevenlyAllocatedFillerMana, Converter={StaticResource PercentConverter}, Mode=TwoWay}" Maximum="100" DecimalPlaces="0" MinWidth="50" />
+				
+				<CheckBox Grid.Column="0" Grid.Row="2" IsChecked="{Binding Path=RefreshLifebloomWithDirectHeals, Mode=TwoWay}" MinWidth="50" Content="Refresh Lifebloom with direct heals" Margin="4,2,2,2" Grid.ColumnSpan="5"/>
+				<CheckBox Grid.Column="0" Grid.Row="3" IsChecked="{Binding Path=RejuvenationTankDuringRaid, Mode=TwoWay}" MinWidth="50" Content="Keep Rejuvenation up on the tank" Margin="4,2,2,2" Grid.ColumnSpan="5"/>
+				<TextBlock Grid.ColumnSpan="1" Margin="4,2,2,2" Text="Mean Efflorescence targets:" TextWrapping="NoWrap" VerticalAlignment="Center" Grid.Row="5" />
+				<inputToolkit:NumericUpDown Margin="2" Grid.Column="1" Grid.Row="5" Value="{Binding Path=EfflorescenceTargets, Mode=TwoWay}" Maximum="3" DecimalPlaces="2" MinWidth="50" />
+
+				<Border Grid.Row="4" Grid.ColumnSpan="5" Background="AliceBlue" BorderBrush="LightSteelBlue" BorderThickness="1">
+					<TextBlock Margin="4" FontWeight="Bold" Text="Multi-target raid healing" VerticalAlignment="Center" />
+				</Border>
+				<TextBlock Grid.ColumnSpan="1" Margin="4,2,2,2" Text="Wild Growth symbiosis rate:" TextWrapping="NoWrap" VerticalAlignment="Center" Grid.Row="6" />
+				<inputToolkit:NumericUpDown Margin="2" Grid.Column="1" Grid.Row="6" Value="{Binding Path=WildGrowthSymbiosisRate, Converter={StaticResource PercentConverter}, Mode=TwoWay}" Maximum="100" DecimalPlaces="0" MinWidth="50" />
+				<TextBlock Grid.ColumnSpan="1" Margin="4,2,2,2" Text="Wild Growth effectiveness:" TextWrapping="NoWrap" VerticalAlignment="Center" Grid.Row="7" />
+				<inputToolkit:NumericUpDown Margin="2" Grid.Column="1" Grid.Row="7" Value="{Binding Path=WildGrowthEffectiveHealing, Converter={StaticResource PercentConverter}, Mode=TwoWay}" Maximum="100" DecimalPlaces="0" MinWidth="50"  />
+				<TextBlock Grid.ColumnSpan="1" Margin="4,2,2,2" Text="Tranquility symbiosis rate:" TextWrapping="NoWrap" VerticalAlignment="Center" Grid.Row="8" />
+				<inputToolkit:NumericUpDown Margin="2" Grid.Column="1" Grid.Row="8" Value="{Binding Path=TranquilitySymbiosisRate, Converter={StaticResource PercentConverter}, Mode=TwoWay}" Maximum="100" DecimalPlaces="0" MinWidth="50" />
+
+				<Border Grid.Row="9" Grid.ColumnSpan="5" Background="AliceBlue" BorderBrush="LightSteelBlue" BorderThickness="1">
+					<TextBlock Margin="4" FontWeight="Bold" Text="Single-target raid healing" VerticalAlignment="Center" />
+				</Border>
+				<TextBlock Grid.ColumnSpan="1" Margin="4,2,2,2" Text="Symbiosis rate:" TextWrapping="NoWrap" VerticalAlignment="Center" Grid.Row="10" />
+				<inputToolkit:NumericUpDown Margin="2" Grid.Column="1" Grid.Row="10" Value="{Binding Path=RaidSTSymbiosisRate, Converter={StaticResource PercentConverter}, Mode=TwoWay}" Maximum="100" DecimalPlaces="0" MinWidth="50" />
+
+				<TextBlock Grid.ColumnSpan="1" Margin="4,2,2,2" Text="ToL Lifebloom effectiveness:" TextWrapping="NoWrap" VerticalAlignment="Center" Grid.Row="11" />
+				<inputToolkit:NumericUpDown Margin="2" Grid.Column="1" Grid.Row="11" Value="{Binding Path=ToLLifebloomEffectiveHealing, Converter={StaticResource PercentConverter}, Mode=TwoWay}" Maximum="100" DecimalPlaces="0" MinWidth="50"  />
+
+				<TextBlock Grid.ColumnSpan="1" Margin="4,2,2,2" Text="Rejuvenation effectiveness:" TextWrapping="NoWrap" VerticalAlignment="Center" Grid.Row="12" />
+				<inputToolkit:NumericUpDown Margin="2" Grid.Column="1" Grid.Row="12" Value="{Binding Path=RejuvenationEffectiveHealing, Converter={StaticResource PercentConverter}, Mode=TwoWay}" Maximum="100" DecimalPlaces="0" MinWidth="50"  />
+
+				<TextBlock Grid.ColumnSpan="1" Margin="4,2,2,2" Text="Healing Touch effectiveness:" TextWrapping="NoWrap" VerticalAlignment="Center" Grid.Row="13" />
+				<inputToolkit:NumericUpDown Margin="2" Grid.Column="1" Grid.Row="13" Value="{Binding Path=HealingTouchEffectiveHealing, Converter={StaticResource PercentConverter}, Mode=TwoWay}" Maximum="100" DecimalPlaces="0" MinWidth="50"  />
+
+				<TextBlock Grid.ColumnSpan="1" Margin="4,2,2,2" Text="Nourish/RG effectiveness:" TextWrapping="NoWrap" VerticalAlignment="Center" Grid.Row="14" />
+				<inputToolkit:NumericUpDown Margin="2" Grid.Column="1" Grid.Row="14" Value="{Binding Path=NourishEffectiveHealing, Converter={StaticResource PercentConverter}, Mode=TwoWay}" Maximum="100" DecimalPlaces="0" MinWidth="50"  />
+			</Grid>
+		</TabItem>
+		<TabItem Header="PTR">
+			<Grid>
+				<Grid.ColumnDefinitions>
+					<ColumnDefinition Width="Auto"/>
+					<ColumnDefinition Width="Auto"/>
+					<ColumnDefinition Width="*" />
+				</Grid.ColumnDefinitions>
+				<Grid.RowDefinitions>
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+					<RowDefinition Height="Auto" />
+				</Grid.RowDefinitions>
+				<Border Grid.Row="0" Grid.ColumnSpan="5" Background="AliceBlue" BorderBrush="LightSteelBlue" BorderThickness="1">
+					<TextBlock Margin="4" FontWeight="Bold" Text="PTR changes" VerticalAlignment="Center" />
+				</Border>
+
+				<CheckBox Grid.Column="0" Grid.Row="1" IsChecked="{Binding Path=Crit100Bonus, Mode=TwoWay}" MinWidth="50" Content="+100% crits" Margin="4,2,2,2" Grid.ColumnSpan="5"/>
+				<CheckBox Grid.Column="0" Grid.Row="2" IsChecked="{Binding Path=Harmony, Mode=TwoWay}" MinWidth="50" Content="Use Harmony mastery (assumes 100% uptime)" Margin="4,2,2,2" Grid.ColumnSpan="5"/>
+
+				<TextBlock Grid.ColumnSpan="1" Margin="4,2,2,2" Text="Harmony coefficient:" TextWrapping="NoWrap" VerticalAlignment="Center" Grid.Row="3" />
+				<inputToolkit:NumericUpDown Margin="2" Grid.Column="1" Grid.Row="3" Value="{Binding Path=HarmonyCoefficient, Converter={StaticResource PercentConverter}, Mode=TwoWay}" Maximum="100" DecimalPlaces="2" MinWidth="50" />
+				<TextBlock Grid.Column="2" Margin="4,2,2,2" Text=" (1.25 on PTR)" TextWrapping="NoWrap" VerticalAlignment="Center" Grid.Row="3" />
+			</Grid>
+
+		</TabItem>
+	</TabControl>
 </UserControl>
Index: Rawr4/Rawr.Tree/Rawr.Tree.WPF.csproj
===================================================================
--- Rawr4/Rawr.Tree/Rawr.Tree.WPF.csproj	(revision 60557)
+++ Rawr4/Rawr.Tree/Rawr.Tree.WPF.csproj	(working copy)
@@ -105,6 +105,9 @@
     </Reference>
   </ItemGroup>
   <ItemGroup>
+    <Compile Include="..\..\Rawr.Tree\Actions.cs">
+      <Link>Actions.cs</Link>
+    </Compile>
     <Compile Include="..\..\Rawr.Tree\CalculationOptionsTree.cs">
       <Link>CalculationOptionsTree.cs</Link>
     </Compile>
@@ -117,16 +120,13 @@
     <Compile Include="..\..\Rawr.Tree\ComparisonCalculationTree.cs">
       <Link>ComparisonCalculationTree.cs</Link>
     </Compile>
-    <Compile Include="..\..\Rawr.Tree\Solver.cs">
-      <Link>Solver.cs</Link>
-    </Compile>
-    <Compile Include="..\..\Rawr.Tree\Spell.cs">
-      <Link>Spell.cs</Link>
-    </Compile>
     <Compile Include="..\..\Rawr3\Rawr.Tree\CalculationOptionsPanelTree.xaml.cs">
       <Link>CalculationOptionsPanelTree.xaml.cs</Link>
       <DependentUpon>CalculationOptionsPanelTree.WPF.xaml</DependentUpon>
     </Compile>
+    <Compile Include="..\..\Rawr.Tree\TreeSolver.cs">
+      <Link>TreeSolver.cs</Link>
+    </Compile>
     <Compile Include="Properties\AssemblyInfo.cs" />
     <AppDesigner Include="Properties\" />
   </ItemGroup>
@@ -135,6 +135,10 @@
       <Project>{542537D3-F86B-4022-A161-B2FC6F0218B7}</Project>
       <Name>Rawr.Base.WPF</Name>
     </ProjectReference>
+    <ProjectReference Include="..\..\Rawr.Moonkin\Rawr.Moonkin.WPF.csproj">
+      <Project>{29946D37-91C4-4D46-9625-D11C8CEE8AFC}</Project>
+      <Name>Rawr.Moonkin.WPF</Name>
+    </ProjectReference>
   </ItemGroup>
   <ItemGroup>
     <Page Include="..\..\Rawr3\Rawr.Tree\CalculationOptionsPanelTree.WPF.xaml">
Index: Rawr4/Rawr.WPF/Rawr.WPF.csproj
===================================================================
--- Rawr4/Rawr.WPF/Rawr.WPF.csproj	(revision 60557)
+++ Rawr4/Rawr.WPF/Rawr.WPF.csproj	(working copy)
@@ -189,6 +189,7 @@
     <Content Include="..\Rawr.Silverlight.Web\ClientBin\ItemCache.xml">
       <Link>ClientBin\ItemCache.xml</Link>
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+      <SubType>Designer</SubType>
     </Content>
     <Content Include="..\Rawr.Silverlight.Web\ClientBin\ItemFilter.xml">
       <Link>ClientBin\ItemFilter.xml</Link>
